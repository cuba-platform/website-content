1
00:00:00,000 --> 00:00:04,566
Всем привет! В этом видео я покажу, как встроить визуальное представление 

2
00:00:04,566 --> 00:00:08,599
геопространственных данных в приложение CUBA с помощью дополнения Maps. 

3
00:00:08,600 --> 00:00:14,833
Работа с геопространственными данными и отображение карт являются неотъемлемой частью множества бизнес-приложений. 

4
00:00:14,833 --> 00:00:19,699
Однако зачастую Java-разработчикам непросто добавить карты в веб-приложение. 

5
00:00:19,700 --> 00:00:24,866
В большинстве случаев   это требует знания фронт-энд технологий (по крайней мере JavaScript). 

6
00:00:24,866 --> 00:00:28,832
И даже если эти знания есть, реализация все равно может оказаться сложной, 

7
00:00:28,833 --> 00:00:35,833
полной шаблонного кода и очень затратной по времени. 

8
00:00:35,833 --> 00:00:40,099
Дополнение Maps поможет вам упростить решение широкого спектра задач, 

9
00:00:40,100 --> 00:00:42,500
связанных с геопространственными данными.

10
00:00:42,500 --> 00:00:46,600
Оно работает с геометрическими типами данных из JTS Topology Suite - 

11
00:00:46,600 --> 00:00:50,633
самой популярной Java -библиотеки для работы с геопространственными данными. 

12
00:00:50,633 --> 00:00:52,899
И позволяет работать с любым провайдером карт, 

13
00:00:52,900 --> 00:00:58,233
совместимым с протоколом Web Map Service или предоставляющим тайлы в формате XYZ. 

14
00:00:58,233 --> 00:01:02,266
Дополнение предоставляет визуальный компонент с 

15
00:01:02,266 --> 00:01:06,632
полнофункциональным и понятным API для создания четко структурированных карт с любым содержанием. 

16
00:01:06,633 --> 00:01:10,533
Интерактивные инструменты позволяют рисовать и редактировать геообъекты. 

17
00:01:10,533 --> 00:01:15,999
Кроме этого, доступны возможности для геоанализа - тепловые карты и кластеризация. 

18
00:01:16,000 --> 00:01:19,066
Компонент поддерживает традиционную многослойную структуру, 

19
00:01:19,066 --> 00:01:22,799
широко используемую в профессиональных геоинформационных системах. 

20
00:01:22,800 --> 00:01:25,800
Слои подразделяются на растровые и векторные.

21
00:01:25,800 --> 00:01:29,200
Это изображение показывает пример использования нескольких слоев для 

22
00:01:29,200 --> 00:01:31,266
построения готовой карты. 

23
00:01:31,266 --> 00:01:33,999
Нижний растровый слой служит основой карты. 

24
00:01:34,000 --> 00:01:39,266
Это может быть слой тайлов, отображающий тайлы, предоставляемые так называемыми тайловыми сервисами в 

25
00:01:39,266 --> 00:01:45,766
формате XYZ (например, OpenStreetMap), или слой WMS, отображающий изображения, 

26
00:01:45,766 --> 00:01:48,432
предоставляемые WMS-сервисами. 

27
00:01:48,433 --> 00:01:50,466
Следующие слои - векторные. 

28
00:01:50,466 --> 00:01:54,532
Они состоят из геообъектов - сущностей с геометрическими атрибутами. 

29
00:01:54,533 --> 00:01:59,366
В нашем случае векторный слой будет содержать районы, представленные полигонами, и клиентов, 

30
00:01:59,366 --> 00:02:03,466
местоположение которых определяется географическими точками. 

31
00:02:03,466 --> 00:02:10,732
Теперь я покажу вам, как создать простое CUBA-приложение с картами всего за 15 минут. 

32
00:02:10,733 --> 00:02:14,499
Возможно, вы уже знакомы с нашим демопроектом Petclinic, 

33
00:02:14,500 --> 00:02:17,733
который можно найти на сайте платформы CUBA. 

34
00:02:17,733 --> 00:02:22,599
Он демонстрирует IT-систему воображаемой ветеринарной клиники для покемонов и уже 

35
00:02:22,600 --> 00:02:27,366
содержит данные о клиентах, питомцах, ветеринарах и приемах. 

36
00:02:27,366 --> 00:02:32,032
Будем использовать это приложение в качестве основы и дополним его картами. 

37
00:02:32,033 --> 00:02:35,133
Сначала взглянем на его исходную модель данных. 

38
00:02:35,133 --> 00:02:39,133
Сущность Owner содержит данные о владельцах питомцев. 

39
00:02:39,133 --> 00:02:45,999
Pet содержит имя, дату рождения и связана с классами Owner и PetType. 

40
00:02:46,000 --> 00:02:51,500
Информация о приеме находится в классе Visit и относится к одному питомцу. 

41
00:02:51,500 --> 00:02:56,233
Сущность Vet  отображает имена ветеринаров, расширяет класс Person  

42
00:02:56,233 --> 00:03:00,399
и связана с классом Specialty. 

43
00:03:00,400 --> 00:03:03,900
Мы расширим модель данных следующим образом. 

44
00:03:03,900 --> 00:03:07,166
Во-первых, добавим новую сущность - клинику. 

45
00:03:07,166 --> 00:03:13,699
Каждая сущность-  это филиал клиники с двумя атрибутами: именем (name) и местоположением (location). 

46
00:03:13,700 --> 00:03:22,133
Атрибут location имеет JTS-тип "точка" и представляет физическое местоположение клиники. 

47
00:03:22,133 --> 00:03:29,566
Еще одна новая сущность - район (District), она показывает область города, ограниченную геометрией полигона. 

48
00:03:29,566 --> 00:03:36,432
Далее, добавим атрибут location к сущности Owner и ссылку на район. 

49
00:03:36,433 --> 00:03:40,933
Наконец, добавим ссылку на Clinic в сущность Visit. 

50
00:03:40,933 --> 00:03:49,666
Когда создается новый прием, филиал клиники будет выбран на основе близости к местоположению владельца питомца. 

51
00:03:49,666 --> 00:03:55,399
Итак, мы собираемся добавить карты на экраны редактора для клиник, владельцев и районов, для 

52
00:03:55,400 --> 00:03:58,700
интерактивного редактирования соответствующей геометрии. 

53
00:03:58,700 --> 00:04:05,466
Мы также реализуем алгоритм, который будет находить ближайшую клинику для клиента при создании нового приема. 

54
00:04:05,466 --> 00:04:08,899
На экран просмотра информации о владельцах мы добавим карту, 

55
00:04:08,900 --> 00:04:13,066
отображающую владельцев, с применением механизма кластеризации.  

56
00:04:13,066 --> 00:04:17,832
Наконец, мы создадим тепловую карту для визуализации общей информации о частоте 

57
00:04:17,833 --> 00:04:22,733
приемов в разных районах города. Теперь мы готовы приступить к разработке 

58
00:04:22,733 --> 00:04:24,433
нашего демоприложения. 

59
00:04:24,433 --> 00:04:29,966
Начнем с клонирования репозитория petclinic на github. 

60
00:04:29,966 --> 00:04:37,166
Откроем проект в Cuba Studio.

61
00:04:37,166 --> 00:04:40,832
Нам нужно добавить дополнение Maps в проект. 

62
00:04:40,833 --> 00:04:45,066
Откроем вкладку Add-ons и перейдем в Marketplace. 

63
00:04:45,066 --> 00:04:48,332
Найдем там дополнение Maps и установим его. 

64
00:04:48,333 --> 00:04:53,099
Если у вас нет подписки, вы можете получить пробную версию дополнения Maps 

65
00:04:53,100 --> 00:04:57,866
на странице дополнения на сайте платформы CUBA.

66
00:04:57,866 --> 00:05:05,366
Перед добавлением карт на экраны приложения подготовим модель данных. 

67
00:05:05,366 --> 00:05:10,466
Давайте создадим сущность Clinic (Клиника).

68
00:05:10,466 --> 00:05:16,999
Зададим ей два параметра: имя, строкового типа, 

69
00:05:17,000 --> 00:05:21,866
и местоположение, с типом GeoPoint. 

70
00:05:21,866 --> 00:05:26,932
Перейдем на вкладку "Текст", чтобы просмотреть код класса. 

71
00:05:26,933 --> 00:05:32,099
Нам нужно добавить несколько аннотаций к атрибуту location. 

72
00:05:32,100 --> 00:05:37,166
Первая аннотация - @Geometry. Она объявляет о том, что значение атрибута должно 

73
00:05:37,166 --> 00:05:40,499
использоваться при отображении гео-объекта на карте. 

74
00:05:40,500 --> 00:05:45,033
Другая аннотация - @Convert из пакета javax.persistence. 

75
00:05:45,033 --> 00:05:49,933
В этой аннотации мы устанавливаем JPA-конвертер, необходимый для преобразования значений 

76
00:05:49,933 --> 00:05:55,799
атрибута между его представлениями в базе данных и Java-коде. 

77
00:05:55,800 --> 00:06:01,866
Мы будем использовать CubaPointWKTConverter, который предоставляется "из коробки". 

78
00:06:01,866 --> 00:06:06,566
Он преобразует точку в строку формата well-known-text и наоборот. 

79
00:06:06,566 --> 00:06:23,099
Таким же способом добавим параметр location к сущности Owner. 

80
00:06:23,100 --> 00:06:31,300
Теперь создадим сущность District (район). 

81
00:06:31,300 --> 00:06:37,600
Зададим два параметра: имя, строкового типа, 

82
00:06:37,600 --> 00:06:41,133
и полигон, с типом GeoPolygon. 

83
00:06:41,133 --> 00:06:45,866
Перейдем на вкладку "Текст", чтобы увидеть код класса. 

84
00:06:45,866 --> 00:06:54,632
И снова, нам нужно добавить аннотации к параметру, задающему геометрию, в данном случае - полигону: @ Geometry и @Convert. 

85
00:06:54,633 --> 00:07:01,633
В  качестве конвертера используем CubaPolygonWKTConverter. 

86
00:07:01,633 --> 00:07:12,633
Добавим ссылку на клинику в сущность Visit. 

87
00:07:12,633 --> 00:07:16,066
Затем нам нужно создать представление для сущности Visit, 

88
00:07:16,066 --> 00:07:18,532
которая включает этот атрибут. 

89
00:07:18,533 --> 00:07:23,066
Кликнем правой кнопкой мыши на сущность Visit и создадим представление. 

90
00:07:23,066 --> 00:07:26,666
Назовем его visit_with_pet_and_clinic. 

91
00:07:26,666 --> 00:07:30,899
Установите visit_with_pet в качестве базового представления. 

92
00:07:30,900 --> 00:07:34,733
Добавим атрибут клиники и его расположение в представление. 

93
00:07:34,733 --> 00:07:54,199
И, наконец, добавим ссылку на район в сущность Owner. 

94
00:07:54,200 --> 00:07:57,066
Создадим представление с этой ссылкой.

95
00:07:57,066 --> 00:08:04,799
Назовем его owner_with_district. Добавим в представление атрибут района и его полигон. 

96
00:08:04,800 --> 00:08:07,766
Мы внесли все необходимые изменения в модель данных, 

97
00:08:07,766 --> 00:08:10,066
теперь пора создать базу данных. 

98
00:08:10,066 --> 00:08:14,732
Перейдем в меню CUBA -> Generate database scripts. 

99
00:08:14,733 --> 00:08:17,966
Нажмем Продолжить, чтобы подтвердить перезапись существующих скриптов 

100
00:08:17,966 --> 00:08:23,566
и создадим базу данных. 

101
00:08:23,566 --> 00:08:27,932
Теперь мы готовы создавать экраны для сущностей Clinic и District. 

102
00:08:27,933 --> 00:08:34,933
Кликнем правой кнопкой мыши по клинике и создадим экраны просмотра и редактора - editor and browser screens. 

103
00:08:34,933 --> 00:08:44,899
Повторим те же действия с сущностью District. 

104
00:08:44,900 --> 00:08:57,933
После того, как мы создали экраны, запускаем сервер, чтобы убедиться, что все работает как надо. 

105
00:08:57,933 --> 00:09:02,533
Мы видим, что созданные экраны появились в меню. 

106
00:09:02,533 --> 00:09:10,366
Приступим к добавлению карт на экраны. 

107
00:09:10,366 --> 00:09:13,499
Добавим карту на экран 

108
00:09:13,500 --> 00:09:18,033
редактора клиники, чтобы пользователь мог указать местоположение клиники прямо на карте. 

109
00:09:18,033 --> 00:09:22,599
Откроем xml-дескриптор экрана редактора клиники. 

110
00:09:22,600 --> 00:09:25,866
Удалим поле locationField, оно нам не нужно. 

111
00:09:25,866 --> 00:09:29,799
Добавим UI компонент geoMap под формой. 

112
00:09:29,800 --> 00:09:34,000
Нажмем Alt + Enter, чтобы добавить пространство имен. 

113
00:09:34,000 --> 00:09:43,100
Укажем основные параметры, такие как ширина, высота, масштаб, координаты центра карты. 

114
00:09:43,100 --> 00:09:49,566
Центр задается значениями долготы и широты, разделенными запятой. 

115
00:09:49,566 --> 00:09:53,899
В нашем демоприложении будем работать с картой Мадрида, поэтому укажем координаты, 

116
00:09:53,900 --> 00:09:57,800
приблизительно соответствующие центру Мадрида. 

117
00:09:57,800 --> 00:10:00,900
После этого нужно объявить слои. 

118
00:10:00,900 --> 00:10:07,400
Наша карта будет иметь только 2 слоя: слой тайлов в качестве подложки 

119
00:10:07,400 --> 00:10:10,733
и векторный слой, содержащий текущую клинику. 

120
00:10:10,733 --> 00:10:14,033
В нашем демо мы используем тайл-сервис OpenStreetMap, 

121
00:10:14,033 --> 00:10:20,133
но вы можете использовать любой другой тайл-сервис, указав URL-шаблон, а также строку атрибуции, 

122
00:10:20,133 --> 00:10:23,566
которую некоторые сервисы требуют добавлять на карту. 

123
00:10:23,566 --> 00:10:30,332
Подробную информацию о тайл-сервисах и WMS-сервисах можно найти в документации дополнения Maps.

124
00:10:30,333 --> 00:10:34,533
Передадим контейнер данных clinicDc в clinicLayer, 

125
00:10:34,533 --> 00:10:39,899
сделаем слой редактируемым, чтобы включить интерактивное редактирование расположения клиники. 

126
00:10:39,900 --> 00:10:43,400
Убедимся, что clinicLayer обозначен как выбранный слой - т.е. слой, 

127
00:10:43,400 --> 00:10:47,466
который будет активным в момент открытия карты. 

128
00:10:47,466 --> 00:10:49,099
Вернемся к приложению. 

129
00:10:49,100 --> 00:10:51,400
Создадим новую клинику.

130
00:10:51,400 --> 00:10:56,433
Мы видим, что на экране появилась карта. Так как расположение клиники еще не определено, 

131
00:10:56,433 --> 00:11:02,499
карта открывается в режиме рисования (это можно понять, увидев курсор-крестик). 

132
00:11:02,500 --> 00:11:05,200
Кликнем по карте, чтобы нарисовать точку. 

133
00:11:05,200 --> 00:11:08,866
После того, как точка нарисована, можем перетащить ее, или удалить, 

134
00:11:08,866 --> 00:11:14,932
выбрав опцию "Clear geometry" (Очистить геометрию) в контекстном меню. 

135
00:11:14,933 --> 00:11:18,766
Аналогично, добавим карту на экран редактора районов. 

136
00:11:18,766 --> 00:11:21,299
Удалим polygonField. 

137
00:11:21,300 --> 00:11:25,633
Добавим UI-компонент geoMap под формой. 

138
00:11:25,633 --> 00:11:29,866
Нажмем Alt + Enter, чтобы добавить пространство имен. 

139
00:11:29,866 --> 00:11:39,366
Большинство параметров будут такими же, как для экрана редактора клиники. 

140
00:11:39,366 --> 00:11:43,299
Добавим векторный слой с districtLayer id. 

141
00:11:43,300 --> 00:11:46,833
Передадим в слой контейнер данных districtDc. 

142
00:11:46,833 --> 00:11:49,866
Сделаем слой редактируемым. 

143
00:11:49,866 --> 00:11:52,699
Обозначим его как выбранный слой. 

144
00:11:52,700 --> 00:11:55,733
Вернемся к приложению и посмотрим на результат. 

145
00:11:55,733 --> 00:11:57,499
Создадим новый район.

146
00:11:57,500 --> 00:12:01,800
Мы видим, что на экран добавлена карта. Чтобы начать рисовать полигон, 

147
00:12:01,800 --> 00:12:06,633
нужно кликнуть по карте. Продолжим рисовать, пока не получим нужную геометрию. 

148
00:12:06,633 --> 00:12:10,933
Чтобы закончить рисование, нужно нажать на последнюю добавленную точку. 

149
00:12:10,933 --> 00:12:14,166
Можно редактировать полигон, перетаскивая его точки. 

150
00:12:14,166 --> 00:12:18,632
Также можно добавить пустую область внутри полигона. 

151
00:12:18,633 --> 00:12:23,466
Выберем опцию  ‘Add hole’ в контекстном меню. 

152
00:12:23,466 --> 00:12:27,066
Затем кликнем на полигон, чтобы начать рисовать внутреннюю область. 

153
00:12:27,066 --> 00:12:31,032
Нажмем на последнюю добавленную точку, чтобы закончить. 

154
00:12:31,033 --> 00:12:36,966
Для очистки полигона используем опцию `Clear geometry` (очистить геометрию) в контекстном меню.

155
00:12:36,966 --> 00:12:41,632
Все изменения в геометрии будут автоматически сохранены после коммита. 

156
00:12:41,633 --> 00:12:50,333
Создадим два района, они нам понадобятся позже.

157
00:12:50,333 --> 00:12:55,399
Мы видим, что таблица содержит текстовое представление полигонов. 

158
00:12:55,400 --> 00:12:59,033
Этот столбец был добавлен автоматически при создании экрана. 

159
00:12:59,033 --> 00:13:01,666
Поскольку это представление для нас не так важно, 

160
00:13:01,666 --> 00:13:04,932
мы можем удалить этот столбец из таблицы. 

161
00:13:04,933 --> 00:13:11,533
Перейдем в дескриптор экрана просмотра района и удалим столбец. 

162
00:13:11,533 --> 00:13:14,966
Теперь добавим карту на экран редактора владельца. 

163
00:13:14,966 --> 00:13:16,932
Перейдем на вкладку Designer.

164
00:13:16,933 --> 00:13:22,133
Здесь много полей, поэтому лучше добавить карту справа. 

165
00:13:22,133 --> 00:13:29,999
Для этого нам нужно добавить hbox на экран и поместить туда fieldGroup и geoMap. 

166
00:13:30,000 --> 00:13:35,800
Добавим hbox в лейаут. Добавим fieldGroup в hbox. 

167
00:13:35,800 --> 00:13:40,333
Помните, что ранее мы добавили ссылку на район в сущности Owner. 

168
00:13:40,333 --> 00:13:43,799
Теперь нам нужно добавить соответствующее поле в fieldGroup. 

169
00:13:43,800 --> 00:13:49,233
Но сначала изменим представление контейнера данных ownerDc на owner-with-district, 

170
00:13:49,233 --> 00:13:53,966
чтобы загрузить соответствующий район вместе с владельцем. 

171
00:13:53,966 --> 00:13:58,332
Потом кликнем по столбцу, затем PROPERTIES -> Add field. 

172
00:13:58,333 --> 00:14:00,066
Добавим параметр района. 

173
00:14:00,066 --> 00:14:06,066
Нам также понадобится контейнер данных для района, чтобы использовать его в векторном слое. 

174
00:14:06,066 --> 00:14:08,232
Перейдем на вкладку PALETTE, 

175
00:14:08,233 --> 00:14:10,266
нажмем на Data components, 

176
00:14:10,266 --> 00:14:16,432
выберем instance-контейнер и поместим его в контейнер ownerDc. 

177
00:14:16,433 --> 00:14:21,266
Перейдем на вкладку PROPERTIES и выберем свойство района. 

178
00:14:21,266 --> 00:14:27,032
Создадим id, нажав кнопку рядом с соответствующим полем. 

179
00:14:27,033 --> 00:14:30,033
Вернемся к XML. 

180
00:14:30,033 --> 00:14:33,233
Добавим компонент geoMap в hbox. 

181
00:14:33,233 --> 00:14:39,499
Установим основные параметры: ширина, высота, масштаб, центр. 

182
00:14:39,500 --> 00:14:41,833
Далее опишем слои. 

183
00:14:41,833 --> 00:14:47,466
Первым будет слой тайлов.

184
00:14:47,466 --> 00:14:51,266
Следующий - districtLayer - векторный слой, отображающий район, 

185
00:14:51,266 --> 00:14:55,366
указанный в соответствующем поле. 

186
00:14:55,366 --> 00:14:59,032
Слой будет обновляться при изменении значения в поле. 

187
00:14:59,033 --> 00:15:03,933
Слой ownerLayer содержит редактируемый экземпляр сущности owner, 

188
00:15:03,933 --> 00:15:07,866
поэтому нужно передать датаконтейнер ownerDc в слой. 

189
00:15:07,866 --> 00:15:15,832
Сделаем слой редактируемым и установим его как выбранный слой. 

190
00:15:15,833 --> 00:15:19,766
Вернемся к приложению. Создадим нового владельца. 

191
00:15:19,766 --> 00:15:23,232
Кликнем по карте, чтобы указать его местоположение. 

192
00:15:23,233 --> 00:15:31,066
Выберем район. Обратите внимание, что соответствующий слой был обновлен при обновлении значения. 

193
00:15:31,066 --> 00:15:34,832
Попробуем выбрать другой район или очистить значение. 

194
00:15:34,833 --> 00:15:38,266
До сих пор мы строили карты только в XML-дескрипторах. 

195
00:15:38,266 --> 00:15:43,966
Но можно также работать с UI-компонентом geoMap и слоями программно в контроллерах экрана. 

196
00:15:43,966 --> 00:15:48,732
Например, в контроллере экрана мы можем настроить стили для точки и полигона. 

197
00:15:48,733 --> 00:15:53,666
Также можно добавить валидацию, чтобы проверить, относится ли местоположение владельца к 

198
00:15:53,666 --> 00:15:59,866
определенному району. Начнем со стилей. Перейдем в контроллер OwnerEdit. 

199
00:15:59,866 --> 00:16:06,732
Чтобы настроить стили геометрии, необходимо задать функцию провайдера стилей для векторного слоя. 

200
00:16:06,733 --> 00:16:12,299
Эта функция вычисляет стиль для определенного геообъекта, расположенного на слое. 

201
00:16:12,300 --> 00:16:17,100
В CUBA 7 появился очень удобный механизм, который позволяет задавать такие функции декларативно, 

202
00:16:17,100 --> 00:16:21,766
без вызова конкретного сеттера. 

203
00:16:21,766 --> 00:16:24,966
Например, чтобы определить провайдер стилей для ownerLayer, 

204
00:16:24,966 --> 00:16:28,066
нужно объявить метод setOwnerLayerStyleProvider, 

205
00:16:28,066 --> 00:16:33,166
который возвращает GeometryStyle, а в качестве аргумента принимает объект Owner. 

206
00:16:33,166 --> 00:16:39,332
Название метода не важно, но оно должно объяснять, для чего он нужен. 

207
00:16:39,333 --> 00:16:45,933
Добавим к методу аннотацию @Install. В параметре “to” нужно указать ID компонента geoMap - 

208
00:16:45,933 --> 00:16:54,733
в нашем случае map, и затем, после точки, ID слоя , в нашем случае - ownerLayer. 

209
00:16:54,733 --> 00:16:58,499
В параметре ‘subject’ укажем styleProvider. 

210
00:16:58,500 --> 00:17:01,100
В теле метода опишем стиль. 

211
00:17:01,100 --> 00:17:05,600
В нашем случае нужно просто возвращать PointStyle с настраиваемой иконкой. 

212
00:17:05,600 --> 00:17:13,100
Сделаем то же самое с districtLayer. 

213
00:17:13,100 --> 00:17:21,000
Теперь нужно, чтобы наш метод возвращал PolygonStyle. 

214
00:17:21,000 --> 00:17:27,766
И наконец, добавим проверку, что владелец находится внутри выбранного района. 

215
00:17:27,766 --> 00:17:33,632
Подпишемся на событие preCommit. 

216
00:17:33,633 --> 00:17:36,266
Пропишем валидацию в теле метода. 

217
00:17:36,266 --> 00:17:44,266
Во-первых, проверим, что значение местоположения и района не пустые. 

218
00:17:44,266 --> 00:17:54,532
Чтобы проверить, находится ли точка в пределах полигона, используем метод within (). 

219
00:17:54,533 --> 00:18:07,099
И если условие не выполняется, коммит отменяется и создается уведомление с соответствующим сообщением.

220
00:18:07,100 --> 00:18:13,533
Вернемся в приложение, откроем редактор владельца. 

221
00:18:13,533 --> 00:18:16,533
Как мы видим, настройки стиля применены к слоям. 

222
00:18:16,533 --> 00:18:23,833
А если мы установим расположение за пределами района, появится сообщение об ошибке. 

223
00:18:23,833 --> 00:18:29,466
Прежде чем мы продолжим, нужно наполнить приложение данными. 

224
00:18:29,466 --> 00:18:35,732
Перейдем по ссылке в описании ниже. Есть два groovy-скрипта с предопределенными сгенерированными данными, 

225
00:18:35,733 --> 00:18:38,066
которые можно импортировать в приложение. 

226
00:18:38,066 --> 00:18:44,999
Скачаем их. 
Возвращаемся в приложение и открываем экран консоли JMX. 

227
00:18:45,000 --> 00:18:49,633
Найдем бин Scripting Manager, введя его имя в поле поиска. 

228
00:18:49,633 --> 00:18:54,199
В параметре RootPath есть путь к каталогу на сервере приложения, 

229
00:18:54,200 --> 00:18:56,866
в который нужно поместить groovy-скрипты. 

230
00:18:56,866 --> 00:19:04,932
Скопируем их в этот каталог. 

231
00:19:04,933 --> 00:19:08,233
Запустим скрипт “import1.groovy". 

232
00:19:08,233 --> 00:19:12,333
Видим сообщение, что импорт завершился успешно. 

233
00:19:12,333 --> 00:19:16,033
Делаем то же самое со скриптом “import2.groovy". 

234
00:19:16,033 --> 00:19:21,299
Теперь, когда приложение наполнено данными, мы можем продолжить работу. 

235
00:19:21,300 --> 00:19:27,100
Перейдем к следующей задаче. При создании приема нам нужно, чтобы ближайшая к владельцу питомца 

236
00:19:27,100 --> 00:19:31,533
клиника выбиралась автоматически. Будем использовать JTS framework, 

237
00:19:31,533 --> 00:19:38,366
который предоставляет большой набор функций и алгоритмов для векторной геометрии. 

238
00:19:38,366 --> 00:19:41,332
Перейдем в дескриптор экрана редактора приемов. 

239
00:19:41,333 --> 00:19:47,833
Изменим представление контейнера данных visitDc на visit-with-pet-and-clinic. 

240
00:19:47,833 --> 00:19:55,433
Также изменим представление контейнера данных petsDc на pet-with-owner-and-type. 

241
00:19:55,433 --> 00:19:59,333
Добавим поле клиники в fieldGroup.

242
00:19:59,333 --> 00:20:07,166
Затем создадим контейнер данных, который будет загружать список клиник. 

243
00:20:07,166 --> 00:20:14,266
Перейдем в контроллер экрана. Подпишемся на событие изменения выбранного питомца для приема. 

244
00:20:14,266 --> 00:20:25,732
Инжектируем контейнер данных с клиниками и поле clinic. 

245
00:20:25,733 --> 00:20:30,766
В теле метода мы сначала проверим, указано ли местоположение владельца питомца. 

246
00:20:30,766 --> 00:20:33,566
Если да, то мы будем перебирать все доступные клиники, 

247
00:20:33,566 --> 00:20:38,132
чтобы найти ближайшую к владельцу питомца. 

248
00:20:38,133 --> 00:20:42,133
Если нет, пользователь должен выбрать клинику вручную. 

249
00:20:42,133 --> 00:20:46,266
Мы используем статический метод distance из класса DistanceOp, 

250
00:20:46,266 --> 00:20:55,732
предоставляемого JTS. Этот метод вычисляет расстояние между двумя точками. 

251
00:20:55,733 --> 00:20:59,766
Вернемся в приложение и создадим новый прием. 

252
00:20:59,766 --> 00:21:04,466
Когда мы выбираем питомца для посещения, видим, что клиника определяется автоматически на 

253
00:21:04,466 --> 00:21:09,366
основе только что реализованного алгоритма. 

254
00:21:09,366 --> 00:21:15,532
В дополнении Maps есть полезные инструменты для геоанализа: кластеризация и тепловые карты. 

255
00:21:15,533 --> 00:21:19,133
Давайте используем эти возможности в нашем демо-приложении. 

256
00:21:19,133 --> 00:21:25,566
Начнем с кластеризации. При открытии экрана просмотра владельца было бы удобно видеть не только таблицу владельцев, 

257
00:21:25,566 --> 00:21:29,932
но и расположение владельцев на карте. 

258
00:21:29,933 --> 00:21:34,566
Мы также можем добавить опцию для отображения владельцев в определенном районе. 

259
00:21:34,566 --> 00:21:39,132
Вернемся в студию и откроем дескриптор экрана просмотра владельца. 

260
00:21:39,133 --> 00:21:45,499
Перейдем на вкладку Designer. Реорганизуем лейаут экрана, чтобы разместить карту справа. 

261
00:21:45,500 --> 00:21:54,533
Добавим hbox с двумя vbox-ами на лейаут. 

262
00:21:54,533 --> 00:22:05,599
Скорректируем параметры размеров hbox-а и vbox-ов. 

263
00:22:05,600 --> 00:22:16,100
Переместим фильтр и таблицу ownersTable в первый vbox. 

264
00:22:16,100 --> 00:22:19,500
Добавим поле поиска во второй vbox. 

265
00:22:19,500 --> 00:22:31,133
Укажем id: districtField и подпись: “District.” 

266
00:22:31,133 --> 00:22:35,699
Нам нужно указать optionsContainer, который содержит все доступные значения поля. 

267
00:22:35,700 --> 00:22:39,700
Для этого сначала добавим на экран новый collection-контейнер. 

268
00:22:39,700 --> 00:22:43,600
Выберем класс: District. 

269
00:22:43,600 --> 00:22:53,133
Затем установим этот контейнер в поле districtField. 

270
00:22:53,133 --> 00:23:01,433
Перейдем к xml-дескриптору и добавим карту под полем districtField. 

271
00:23:01,433 --> 00:23:14,533
Установим ширину: 100% 

272
00:23:14,533 --> 00:23:19,166
и установим map в параметр expand для vbox. 

273
00:23:19,166 --> 00:23:28,199
Добавим слой тайлов и векторный слой, отображающий владельцев. 

274
00:23:28,200 --> 00:23:31,166
Вернемся к приложению, чтобы проверить результат. 

275
00:23:31,166 --> 00:23:34,799
Итак, вот так выглядит карта, когда кластеризация отключена. 

276
00:23:34,800 --> 00:23:37,933
На карте слишком много точек, что не только неаккуратно выглядит, 

277
00:23:37,933 --> 00:23:40,833
но и негативно сказывается на производительности. 

278
00:23:40,833 --> 00:23:46,133
Чтобы включить кластеризацию, нужно добавить тег cluster внутри тега vector. 

279
00:23:46,133 --> 00:23:48,933
В теге cluster можно указать дополнительные параметры, 

280
00:23:48,933 --> 00:23:52,366
но в нашем случае просто оставим их по умолчанию. 

281
00:23:52,366 --> 00:23:56,232
Следующее, что мы собираемся сделать - это фильтрация по районам. 

282
00:23:56,233 --> 00:24:03,966
Подпишемся на изменения в districtField.

283
00:24:03,966 --> 00:24:06,666
Инжектируем загрузчик данных владельцев. 

284
00:24:06,666 --> 00:24:10,566
Создадим load context, чтобы применить дополнительное условие: 

285
00:24:10,566 --> 00:24:17,199
загружать только тех владельцев, которые находятся в указанном районе. 

286
00:24:17,200 --> 00:24:25,100
Используем dataManager для загрузки сущностей из базы данных. 

287
00:24:25,100 --> 00:24:29,300
Также нам нужно, чтобы границы выбранного района отображались на карте. 

288
00:24:29,300 --> 00:24:33,800
Чтобы это сделать, нужно добавить полигон района на слой карты Canvas. 

289
00:24:33,800 --> 00:24:37,600
Canvas - это вспомогательный слой UI-компонента geoMap, 

290
00:24:37,600 --> 00:24:42,366
который предоставляет простой API для добавления и рисования геометрий на карте. 

291
00:24:42,366 --> 00:24:47,032
Он полезен в том случае, когда нужно работать с геометрией на карте, не используя при этом сущности, 

292
00:24:47,033 --> 00:24:55,366
как в векторных слоях. Чтобы использовать Canvas, нужно вызвать метод getCanvas UI-компонента GeoMap.

293
00:24:55,366 --> 00:25:02,766
Создадим переменную, которая будет содержать отображаемый на данный момент полигон. 

294
00:25:02,766 --> 00:25:16,999
Эта переменная будет использоваться для удаления полигона с Canvas при изменении выбранного района.

295
00:25:17,000 --> 00:25:25,700
И, наконец, реализуем возможность выбора владельца на карте и заставим таблицу автоматически выделять строку с выбранным владельцем. 

296
00:25:25,700 --> 00:25:30,966
Создадим метод, который принимает GeoObjectSelectedEvent в качестве аргумента 

297
00:25:30,966 --> 00:25:33,832
и подписывается на события слоя владельцев. 

298
00:25:33,833 --> 00:25:40,999
В теле метода пропишем выбор нужного элемента в таблице. 

299
00:25:41,000 --> 00:25:45,333
Вернемся к приложению, чтобы посмотреть на результат. 

300
00:25:45,333 --> 00:25:49,066
Теперь владельцы группируются в кластеры. 

301
00:25:49,066 --> 00:25:52,632
Выберем какой-нибудь район, чтобы увидеть живущих в нем владельцев. 

302
00:25:52,633 --> 00:25:57,466
Если нажать на какого-нибудь владельца, он также будет выбран в таблице. 

303
00:25:57,466 --> 00:26:01,832
Теперь мы можем приступить к последней задаче - созданию тепловой карты приемов. 

304
00:26:01,833 --> 00:26:04,933
Карта будет отображать местоположение владельцев питомцев, 

305
00:26:04,933 --> 00:26:11,266
но интенсивность каждой точки будет зависеть от того, на сколько приемов записывался владелец. 

306
00:26:11,266 --> 00:26:18,166
Таким образом, эта карта должна показывать, какие районы города лучше всего подходят для открытия новой клиники.

307
00:26:18,166 --> 00:26:29,799
Вернемся в студию и создадим новый пустой экран в каталоге visit и назовем его: Visits 

308
00:26:29,800 --> 00:26:38,400
Heatmap.Перейдем в XML-дескриптор и добавим визуальный компонент geoMap на экран. 

309
00:26:38,400 --> 00:26:47,266
Установим ширину и высоту 100%, чтобы сделать карту полноэкранной. 

310
00:26:47,266 --> 00:26:52,932
Пока мы добавим только один слой тайлов OpenStreetMap. 

311
00:26:52,933 --> 00:26:55,033
Перейдем в дизайнер. 

312
00:26:55,033 --> 00:27:03,466
Нам понадобятся два контейнера данных: для клиник и приемов. 

313
00:27:03,466 --> 00:27:06,666
Приемы должны загружаться вместе с владельцем питомца, 

314
00:27:06,666 --> 00:27:09,499
поэтому нам нужно объявить новое представление. 

315
00:27:09,500 --> 00:27:18,633
Назовем его:  visits-with-pet-and-owner. 

316
00:27:18,633 --> 00:27:23,633
Вернемся к xml-дескриптору и добавим новый векторный слой с клиниками. 

317
00:27:23,633 --> 00:27:26,933
Настроим внешний вид точек клиник. 

318
00:27:26,933 --> 00:27:42,733
Перейдем на контроллер экрана и добавим метод, аналогичный созданному ранее на экране OwnerEditor. 

319
00:27:42,733 --> 00:27:47,599
Настроим для точки значок HOSPITAL и сделаем его красным. 

320
00:27:47,600 --> 00:27:50,400
Теперь все готово к добавлению тепловой карты. 

321
00:27:50,400 --> 00:27:53,833
Подпишемся на событие экрана BeforeShow. 

322
00:27:53,833 --> 00:28:00,399
Загрузим данные в контейнеры данных, вызвав метод getScreenData ().loadAll. 

323
00:28:00,400 --> 00:28:07,633
Сначала нужно построить набор пар: точка и ее значение интенсивности типа Double. 

324
00:28:07,633 --> 00:28:31,066
Инжектируем контейнер данных c объектами Visit и создадим intensityMap, используя Stream API. 

325
00:28:31,066 --> 00:28:39,032
Инжектируем UI-компонент geoMap и добавим к нему intensityMap, вызвав метод addHeatMap. 

326
00:28:39,033 --> 00:28:44,199
Можно задать дополнительные параметры для тепловой карты, создав экземпляр класса HeatMapOptions, 

327
00:28:44,200 --> 00:29:01,033
указав необходимые параметры и передав этот объект методу вместе с intensityMap. 

328
00:29:01,033 --> 00:29:08,166
Перезапустим приложение, чтобы применить созданный экран. 

329
00:29:08,166 --> 00:29:12,266
Перейдем на экран Visits Heatmap, чтобы посмотреть на тепловую карту. 

330
00:29:12,266 --> 00:29:19,066
Если бы нам было нужно открыть новую клинику, эта информация оказалась бы очень полезной. 

331
00:29:19,066 --> 00:29:21,199
Итак, мы сделали все, что планировали. 

332
00:29:21,200 --> 00:29:26,266
Присоединяйтесь к сообществу и смело задавайте любые вопросы. 

333
00:29:26,266 --> 00:29:29,999
Скачивайте и используйте другие дополнения из каталога CUBA. 

334
00:29:30,000 --> 00:29:33,700
Ответы на многие вопросы можно найти в документации на нашем сайте. 

335
00:29:33,700 --> 00:29:39,933
Подписывайтесь на нас на GItHub, на наш Twitter и YouTube-канал! Все ссылки доступны под видео. Спасибо за просмотр!

