
## Карты в CUBA-приложениях

Всем привет! В этом видео я покажу, как встроить визуальное представление геопространственных данных в приложение CUBA с помощью дополнения Maps. 
Работа с геопространственными данными и отображение карт являются неотъемлемой частью множества бизнес-приложений. Однако зачастую Java-разработчикам непросто добавить карты в веб-приложение. В большинстве случаев   это требует знания фронт-энд технологий (по крайней мере JavaScript). 
И даже если эти знания есть, реализация все равно может оказаться сложной, полной шаблонного кода и очень затратной по времени. Дополнение Maps поможет вам упростить решение широкого спектра задач, связанных с геопространственными данными.
Оно работает с геометрическими типами данных из JTS Topology Suite - самой популярной Java -библиотеки для работы с геопространственными данными. 
И позволяет работать с любым провайдером карт, совместимым с протоколом Web Map Service или предоставляющим тайлы в формате XYZ. 
Дополнение предоставляет визуальный компонент с полнофункциональным и понятным API для создания четко структурированных карт с любым содержанием. 
Интерактивные инструменты позволяют рисовать и редактировать геообъекты. Кроме этого, доступны возможности для геоанализа - тепловые карты и кластеризация. 

## Многослойная структура

Компонент поддерживает традиционную многослойную структуру, широко используемую в профессиональных геоинформационных системах. 
Слои подразделяются на растровые и векторные.
Это изображение показывает пример использования нескольких слоев для построения готовой карты. Нижний растровый слой служит основой карты. 
Это может быть слой тайлов, отображающий тайлы, предоставляемые так называемыми тайловыми сервисами в формате XYZ (например, OpenStreetMap), или слой WMS, отображающий изображения, предоставляемые WMS-сервисами. 
Следующие слои - векторные. Они состоят из геообъектов - сущностей с геометрическими атрибутами. 
В нашем случае векторный слой будет содержать районы, представленные полигонами, и клиентов, местоположение которых определяется географическими точками.

## Демоприложение

Теперь я покажу вам, как создать простое CUBA-приложение с картами всего за 15 минут. Возможно, вы уже знакомы с нашим демопроектом Petclinic, который можно найти на сайте платформы CUBA. Он демонстрирует IT-систему воображаемой ветеринарной клиники для покемонов и уже содержит данные о клиентах, питомцах, ветеринарах и приемах. 
Будем использовать это приложение в качестве основы и дополним его картами. Сначала взглянем на его исходную модель данных. 
Сущность Owner содержит данные о владельцах питомцев. Pet содержит имя, дату рождения и связана с классами Owner и PetType. Информация о приеме находится в классе Visit и относится к одному питомцу. 
Сущность Vet  отображает имена ветеринаров, расширяет класс Person  и связана с классом Specialty. 
Мы расширим модель данных следующим образом. Во-первых, добавим новую сущность - клинику. 
Каждая сущность-  это филиал клиники с двумя атрибутами: именем (name) и местоположением (location). Атрибут location имеет JTS-тип "точка" и представляет физическое местоположение клиники. Еще одна новая сущность - район (District), она показывает область города, ограниченную геометрией полигона. 
Далее, добавим атрибут location к сущности Owner и ссылку на район. 
Наконец, добавим ссылку на Clinic в сущность Visit. Когда создается новый прием, филиал клиники будет выбран на основе близости к местоположению владельца питомца. 
Итак, мы собираемся добавить карты на экраны редактора для клиник, владельцев и районов, для интерактивного редактирования соответствующей геометрии. 
Мы также реализуем алгоритм, который будет находить ближайшую клинику для клиента при создании нового приема. 
На экран просмотра информации о владельцах мы добавим карту, отображающую владельцев, с применением механизма кластеризации.  Наконец, мы создадим тепловую карту для визуализации общей информации о частоте приемов в разных районах города. 
Теперь мы готовы приступить к разработке нашего демоприложения. Начнем с клонирования репозитория petclinic на github. Откроем проект в Cuba Studio.
Нам нужно добавить дополнение Maps в проект. Откроем вкладку Add-ons и перейдем в Marketplace. 
Найдем там дополнение Maps и установим его. Если у вас нет подписки, вы можете получить пробную версию дополнения Maps на странице дополнения на сайте платформы CUBA. 

## Расширенная модель данных

Перед добавлением карт на экраны приложения подготовим модель данных. Давайте создадим сущность Clinic (Клиника).
Зададим ей два параметра: имя, строкового типа, и местоположение, с типом GeoPoint. Перейдем на вкладку "Текст", чтобы просмотреть код класса. 
Нам нужно добавить несколько аннотаций к атрибуту location. 
Первая аннотация - @Geometry. Она объявляет о том, что значение атрибута должно использоваться при отображении гео-объекта на карте. 
Другая аннотация - @Convert из пакета javax.persistence. 
В этой аннотации мы устанавливаем JPA-конвертер, необходимый для преобразования значений атрибута между его представлениями в базе данных и Java-коде. 
Мы будем использовать CubaPointWKTConverter, который предоставляется "из коробки". Он преобразует точку в строку формата well-known-text и наоборот. 
Таким же способом добавим параметр location к сущности Owner. Теперь создадим сущность District (район). 
Зададим два параметра: имя, строкового типа, и полигон, с типом GeoPolygon. Перейдем на вкладку "Текст", чтобы увидеть код класса. 
И снова, нам нужно добавить аннотации к параметру, задающему геометрию, в данном случае - полигону: @ Geometry и @Convert. 
В  качестве конвертера используем CubaPolygonWKTConverter. Добавим ссылку на клинику в сущность Visit. Затем нам нужно создать представление для сущности Visit, которая включает этот атрибут. 
Кликнем правой кнопкой мыши на сущность Visit и создадим представление. Назовем его visit_with_pet_and_clinic. 
Установите visit_with_pet в качестве базового представления. Добавим атрибут клиники и его расположение в представление. 
И, наконец, добавим ссылку на район в сущность Owner. Создадим представление с этой ссылкой.
Назовем его owner_with_district. Добавим в представление атрибут района и его полигон. 
Мы внесли все необходимые изменения в модель данных, теперь пора создать базу данных. Перейдем в меню CUBA -> Generate database scripts. 
Нажмем Продолжить, чтобы подтвердить перезапись существующих скриптов и создадим базу данных. 
Теперь мы готовы создавать экраны для сущностей Clinic и District. Кликнем правой кнопкой мыши по клинике и создадим экраны просмотра и редактора - editor and browser screens. 
Повторим те же действия с сущностью District. После того, как мы создали экраны, запускаем сервер, чтобы убедиться, что все работает как надо. 
Мы видим, что созданные экраны появились в меню.

## Добавление карт на экраны

Приступим к добавлению карт на экраны. Добавим карту на экран редактора клиники, чтобы пользователь мог указать местоположение клиники прямо на карте. 
Откроем xml-дескриптор экрана редактора клиники. Удалим поле locationField, оно нам не нужно. 
Добавим UI компонент geoMap под формой. Нажмем Alt + Enter, чтобы добавить пространство имен. 
Укажем основные параметры, такие как ширина, высота, масштаб, координаты центра карты. 
Центр задается значениями долготы и широты, разделенными запятой. 

В нашем демоприложении будем работать с картой Мадрида, поэтому укажем координаты, приблизительно соответствующие центру Мадрида. 
После этого нужно объявить слои. Наша карта будет иметь только 2 слоя: слой тайлов в качестве подложки и векторный слой, содержащий текущую клинику. 
В нашем демо мы используем тайл-сервис OpenStreetMap, но вы можете использовать любой другой тайл-сервис, указав URL-шаблон, а также строку атрибуции, которую некоторые сервисы требуют добавлять на карту. 

Подробную информацию о тайл-сервисах и WMS-сервисах можно найти в документации дополнения Maps.
Передадим контейнер данных clinicDc в clinicLayer, сделаем слой редактируемым, чтобы включить интерактивное редактирование расположения клиники. 
Убедимся, что clinicLayer обозначен как выбранный слой - т.е. слой, который будет активным в момент открытия карты. 
Вернемся к приложению. Создадим новую клинику.

Мы видим, что на экране появилась карта. Так как расположение клиники еще не определено, карта открывается в режиме рисования (это можно понять, увидев курсор-крестик). 
Кликнем по карте, чтобы нарисовать точку. После того, как точка нарисована, можем перетащить ее, или удалить, выбрав опцию "Clear geometry" (Очистить геометрию) в контекстном меню. Аналогично, добавим карту на экран редактора районов. Удалим polygonField. Добавим UI-компонент geoMap под формой. Нажмем Alt + Enter, чтобы добавить пространство имен. Большинство параметров будут такими же, как для экрана редактора клиники. Добавим векторный слой с districtLayer id. 
Передадим в слой контейнер данных districtDc. Сделаем слой редактируемым. Обозначим его как выбранный слой. 
Вернемся к приложению и посмотрим на результат. Создадим новый район.

Мы видим, что на экран добавлена карта. Чтобы начать рисовать полигон, нужно кликнуть по карте. 
Продолжим рисовать, пока не получим нужную геометрию. Чтобы закончить рисование, нужно нажать на последнюю добавленную точку. Можно редактировать полигон, перетаскивая его точки. 
Также можно добавить пустую область внутри полигона. 
Выберем опцию  ‘Add hole’ в контекстном меню. Затем кликнем на полигон, чтобы начать рисовать внутреннюю область. 
Нажмем на последнюю добавленную точку, чтобы закончить. Для очистки полигона используем опцию `Clear geometry` (очистить геометрию) в контекстном меню.
Все изменения в геометрии будут автоматически сохранены после коммита. Создадим два района, они нам понадобятся позже.

Мы видим, что таблица содержит текстовое представление полигонов. Этот столбец был добавлен автоматически при создании экрана. 
Поскольку это представление для нас не так важно, мы можем удалить этот столбец из таблицы. Перейдем в дескриптор экрана просмотра района и удалим столбец. 
Теперь добавим карту на экран редактора владельца. Перейдем на вкладку Designer.

Здесь много полей, поэтому лучше добавить карту справа. Для этого нам нужно добавить hbox на экран и поместить туда fieldGroup и geoMap. 
Добавим hbox в лейаут. Добавим fieldGroup в hbox. Помните, что ранее мы добавили ссылку на район в сущности Owner. Теперь нам нужно добавить соответствующее поле в fieldGroup. 
Но сначала изменим представление контейнера данных ownerDc на owner-with-district, чтобы загрузить соответствующий район вместе с владельцем. 

Потом кликнем по столбцу, затем PROPERTIES -> Add field. Добавим параметр района. Нам также понадобится контейнер данных для района, чтобы использовать его в векторном слое. 
Перейдем на вкладку PALETTE, нажмем на Data components, выберем instance-контейнер и поместим его в контейнер ownerDc. Перейдем на вкладку PROPERTIES и выберем свойство района. 
Создадим id, нажав кнопку рядом с соответствующим полем. Вернемся к XML. Добавим компонент geoMap в hbox. Установим основные параметры: ширина, высота, масштаб, центр. 
Далее опишем слои. Первым будет слой тайлов.

Следующий - districtLayer - векторный слой, отображающий район, указанный в соответствующем поле. Слой будет обновляться при изменении значения в поле. 
Слой ownerLayer содержит редактируемый экземпляр сущности owner, поэтому нужно передать датаконтейнер ownerDc в слой. 
Сделаем слой редактируемым и установим его как выбранный слой. Вернемся к приложению. Создадим нового владельца. 
Кликнем по карте, чтобы указать его местоположение. Выберем район. Обратите внимание, что соответствующий слой был обновлен при обновлении значения. 
Попробуем выбрать другой район или очистить значение. До сих пор мы строили карты только в XML-дескрипторах. 

Но можно также работать с UI-компонентом geoMap и слоями программно в контроллерах экрана. 
Например, в контроллере экрана мы можем настроить стили для точки и полигона. 
Также можно добавить валидацию, чтобы проверить, относится ли местоположение владельца к определенному району. Начнем со стилей. Перейдем в контроллер OwnerEdit. 
Чтобы настроить стили геометрии, необходимо задать функцию провайдера стилей для векторного слоя. Эта функция вычисляет стиль для определенного геообъекта, расположенного на слое. 
В CUBA 7 появился очень удобный механизм, который позволяет задавать такие функции декларативно, без вызова конкретного сеттера. 

Например, чтобы определить провайдер стилей для ownerLayer, нужно объявить метод setOwnerLayerStyleProvider, который возвращает GeometryStyle, а в качестве аргумента принимает объект Owner. Название метода не важно, но оно должно объяснять, для чего он нужен. Добавим к методу аннотацию @Install. 
В параметре “to” нужно указать ID компонента geoMap - в нашем случае map, и затем, после точки, ID слоя , в нашем случае - ownerLayer. 
В параметре ‘subject’ укажем styleProvider. В теле метода опишем стиль. В нашем случае нужно просто возвращать PointStyle с настраиваемой иконкой. 

Сделаем то же самое с districtLayer. Теперь нужно, чтобы наш метод возвращал PolygonStyle. И наконец, добавим проверку, что владелец находится внутри выбранного района. 
Подпишемся на событие preCommit. Пропишем валидацию в теле метода. Во-первых, проверим, что значение местоположения и района не пустые. 
Чтобы проверить, находится ли точка в пределах полигона, используем метод within (). 
И если условие не выполняется, коммит отменяется и создается уведомление с соответствующим сообщением.

Вернемся в приложение, откроем редактор владельца. Как мы видим, настройки стиля применены к слоям. А если мы установим расположение за пределами района, появится сообщение об ошибке.

## Наполнение приложения данными

Прежде чем мы продолжим, нужно наполнить приложение данными. Перейдем по ссылке в описании ниже. Есть два groovy-скрипта с предопределенными сгенерированными данными, которые можно импортировать в приложение. Скачаем их. 

Возвращаемся в приложение и открываем экран консоли JMX. Найдем бин Scripting Manager, введя его имя в поле поиска. 
В параметре RootPath есть путь к каталогу на сервере приложения, в который нужно поместить groovy-скрипты. 
Скопируем их в этот каталог. Запустим скрипт “import1.groovy". Видим сообщение, что импорт завершился успешно. Делаем то же самое со скриптом “import2.groovy". 
Теперь, когда приложение наполнено данными, мы можем продолжить работу. 

## Выбор ближайшей клиники

Перейдем к следующей задаче. При создании приема нам нужно, чтобы ближайшая к владельцу питомца клиника выбиралась автоматически. 
Будем использовать JTS framework, который предоставляет большой набор функций и алгоритмов для векторной геометрии. 
Перейдем в дескриптор экрана редактора приемов. 
Изменим представление контейнера данных visitDc на visit-with-pet-and-clinic. 
Также изменим представление контейнера данных petsDc на pet-with-owner-and-type. Добавим поле клиники в fieldGroup.

Затем создадим контейнер данных, который будет загружать список клиник. Перейдем в контроллер экрана. 
Подпишемся на событие изменения выбранного питомца для приема. Инжектируем контейнер данных с клиниками и поле clinic. 
В теле метода мы сначала проверим, указано ли местоположение владельца питомца. 
Если да, то мы будем перебирать все доступные клиники, чтобы найти ближайшую к владельцу питомца. Если нет, пользователь должен выбрать клинику вручную. 
Мы используем статический метод distance из класса DistanceOp, предоставляемого JTS. 
Этот метод вычисляет расстояние между двумя точками. Вернемся в приложение и создадим новый прием. 
Когда мы выбираем питомца для посещения, видим, что клиника определяется автоматически на основе только что реализованного алгоритма. 

## Кластеризация

В дополнении Maps есть полезные инструменты для геоанализа: кластеризация и тепловые карты. 
Давайте используем эти возможности в нашем демо-приложении. Начнем с кластеризации. 
При открытии экрана просмотра владельца было бы удобно видеть не только таблицу владельцев, но и расположение владельцев на карте. 
Мы также можем добавить опцию для отображения владельцев в определенном районе. 
Вернемся в студию и откроем дескриптор экрана просмотра владельца. Перейдем на вкладку Designer. 

Реорганизуем лейаут экрана, чтобы разместить карту справа. Добавим hbox с двумя vbox-ами на лейаут. Скорректируем параметры размеров hbox-а и vbox-ов. 
Переместим фильтр и таблицу ownersTable в первый vbox. Добавим поле поиска во второй vbox. Укажем id: districtField и подпись: “District.” 
Нам нужно указать optionsContainer, который содержит все доступные значения поля. Для этого сначала добавим на экран новый collection-контейнер. 
Выберем класс: District. Затем установим этот контейнер в поле districtField. Перейдем к xml-дескриптору и добавим карту под полем districtField. 
Установим ширину: 100% и установим map в параметр expand для vbox. Добавим слой тайлов и векторный слой, отображающий владельцев. 
Вернемся к приложению, чтобы проверить результат. Итак, вот так выглядит карта, когда кластеризация отключена. 

На карте слишком много точек, что не только неаккуратно выглядит, но и негативно сказывается на производительности. 
Чтобы включить кластеризацию, нужно добавить тег cluster внутри тега vector. В теге cluster можно указать дополнительные параметры, но в нашем случае просто оставим их по умолчанию. Следующее, что мы собираемся сделать - это фильтрация по районам. Подпишемся на изменения в districtField.
Инжектируем загрузчик данных владельцев. Создадим load context, чтобы применить дополнительное условие: загружать только тех владельцев, которые находятся в указанном районе. Используем dataManager для загрузки сущностей из базы данных. 

Также нам нужно, чтобы границы выбранного района отображались на карте. Чтобы это сделать, нужно добавить полигон района на слой карты Canvas. 
Canvas - это вспомогательный слой UI-компонента geoMap, который предоставляет простой API для добавления и рисования геометрий на карте. Он полезен в том случае, когда нужно работать с геометрией на карте, не используя при этом сущности, как в векторных слоях. 
Чтобы использовать Canvas, нужно вызвать метод getCanvas UI-компонента GeoMap.
Создадим переменную, которая будет содержать отображаемый на данный момент полигон. 

Эта переменная будет использоваться для удаления полигона с Canvas при изменении выбранного района.
И, наконец, реализуем возможность выбора владельца на карте и заставим таблицу автоматически выделять строку с выбранным владельцем. Создадим метод, который принимает GeoObjectSelectedEvent в качестве аргумента и подписывается на события слоя владельцев. 
В теле метода пропишем выбор нужного элемента в таблице. Вернемся к приложению, чтобы посмотреть на результат. Теперь владельцы группируются в кластеры. 
Выберем какой-нибудь район, чтобы увидеть живущих в нем владельцев. Если нажать на какого-нибудь владельца, он также будет выбран в таблице. 

## Тепловая карта

Теперь мы можем приступить к последней задаче - созданию тепловой карты приемов. Карта будет отображать местоположение владельцев питомцев, но интенсивность каждой точки будет зависеть от того, на сколько приемов записывался владелец. 
Таким образом, эта карта должна показывать, какие районы города лучше всего подходят для открытия новой клиники.
Вернемся в студию и создадим новый пустой экран в каталоге visit и назовем его: Visits Heatmap. 

Перейдем в XML-дескриптор и добавим визуальный компонент geoMap на экран. Установим ширину и высоту 100%, чтобы сделать карту полноэкранной. 
Пока мы добавим только один слой тайлов OpenStreetMap. Перейдем в дизайнер. Нам понадобятся два контейнера данных: для клиник и приемов. 
Приемы должны загружаться вместе с владельцем питомца, поэтому нам нужно объявить новое представление. 
Назовем его:  visits-with-pet-and-owner. Вернемся к xml-дескриптору и добавим новый векторный слой с клиниками. 
Настроим внешний вид точек клиник. 
Перейдем на контроллер экрана и добавим метод, аналогичный созданному ранее на экране OwnerEditor. 
Настроим для точки значок HOSPITAL и сделаем его красным. 

Теперь все готово к добавлению тепловой карты. Подпишемся на событие экрана BeforeShow. 
Загрузим данные в контейнеры данных, вызвав метод getScreenData ().loadAll. Сначала нужно построить набор пар: точка и ее значение интенсивности типа Double. 
Инжектируем контейнер данных c объектами Visit и создадим intensityMap, используя Stream API. 
Инжектируем UI-компонент geoMap и добавим к нему intensityMap, вызвав метод addHeatMap. 

Можно задать дополнительные параметры для тепловой карты, создав экземпляр класса HeatMapOptions, указав необходимые параметры и передав этот объект методу вместе с intensityMap. Перезапустим приложение, чтобы применить созданный экран. Перейдем на экран Visits Heatmap, чтобы посмотреть на тепловую карту. 
Если бы нам было нужно открыть новую клинику, эта информация оказалась бы очень полезной. 

## Заключение

Итак, мы сделали все, что планировали. Присоединяйтесь к сообществу и смело задавайте любые вопросы. 
Скачивайте и используйте другие дополнения из каталога CUBA. Ответы на многие вопросы можно найти в документации на нашем сайте. Подписывайтесь на нас на GItHub, на наш Twitter и YouTube-канал! Все ссылки доступны под видео. Спасибо за просмотр!
