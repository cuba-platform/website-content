
## Dashboards in CUBA Applications

Всем привет! Cегодня я покажу вам, как создавать дашборды в CUBA-приложениях. 
Дашборд - это отличный способ визуализации информации, но часто Java-разработчики сталкиваются с проблемами при добавлении дашбордов, например, из-за ресурсоемкой и затрудненной реализации или отсутствия front-end разработчика в команде. 
Мы хотим показать вам простой способ представления визуальной информации с помощью open source-дополнения Dashboards. Оно доступно в Каталоге дополнений и на GitHub’е. 
Любой дашборд состоит из виджетов - отдельных визуальных элементов интерфейса. 
Разместить виджеты на дашборде в нужном порядке можно с помощью широкого набора компоновок - лейаутов. 
Например, адаптивный лейаут подстроит дашборд для отображения на компьютере, планшете или смартфоне. 
Также можно настроить обновление данных на дашборде и взаимодействие между виджетами.

## Demo Application

А сейчас я покажу вам, как создать и настроить дашборд всего за 15 минут. 
Возможно, вы уже знакомы с нашим демопроектом Petclinic, который можно найти на сайте платформы CUBA. Он демонстрирует IT-систему воображаемой ветеринарной клиники для покемонов и уже содержит данные о клиентах, питомцах, ветеринарах и приемах. 
Будем использовать это приложение в качестве основы и добавим в него несколько виджетов и дашбордов. 

## Domain Model

Сначала посмотрим на его доменную модель. Сущность Owner содержит данные о владельцах питомцев. 
Pet содержит имя, дату рождения и связана с классами Owner и PetType. Информация о приеме находится в классе Visit и относится к одному питомцу. 
Сущность Vet  отображает имена ветеринаров, расширяет класс Person  и связана с классом Specialty. 

## Cloning the Demo Application

Теперь мы готовы начать. Зайдем в репозиторий Pet Clinic на github. Скопируем его и откроем проект в CUBA studio. 
Теперь добавим в проект дополнение для дашбордов. Откроем окно Add-ons и перейдем в Marketplace. Найдем дополнение Dashboards. 
Нажмем Install и применим изменения. Видим, что зависимости дополнения добавлены в файл build.gradle и web.xml в core и web модулях. 
Теперь запустим приложение. Применим скрипты создания базы данных и перейдем по ссылке, чтобы открыть приложение. Залогинимся в роли администратора. 
Видим, что в главном меню появился еще один основной раздел - Dashboards. Давайте создадим дашборд с именем Main Dashboard. 
Сейчас мы можем добавить лейаут, но у нас пока нет ни одного виджета, доступного для добавления. Давайте создадим несколько виджетов. 

## Simple Widget

Для начала добавим совсем простой виджет. Он будет показывать изображение Пикачу, скачанное из Википедии. 
Чтобы создать новый виджет, сначала нужно создать новый фрагмент экрана. Поместим его в пакет widgets и назовем pokemon-art-widget. 
Затем добавим подкаталог “images” в  modules/web/ и поместим туда загруженное изображение. 
Также обновим задачу deploy в build.gradle, чтобы использовать картинку в приложении. 
Окей, следующим шагом поместим картинку на наш фрагмент экрана с помощью опции загрузки relativePath. 
Ну а теперь - магия! Добавим аннотацию @DashboardWidget в наш фрагмент экрана и передадим ему имя виджета, которое будет использовать редактор дашборда. 
Отлично! Наш первый виджет готов. Запустим приложение и посмотрим, что оно умеет! Открываем дашборд в редакторе и - вуаля! - наш новенький виджет уже здесь! 
Теперь оформим наш дашборд. Добавим адаптивный лейаут в качестве корневого элемента. Настройки оставим по умолчанию. 
Добавим сюда наш виджет Pokemon Art. Сделаем к нему подпись и установим id, соответствующий названию. 
Сделаем подпись отображаемой. В настройках стиля установим ширину и высоту виджета - авто. Сохраним изменения. 
Теперь самое время поговорить о встроенных возможностях редактирования виджетов. 
Можно настроить подпись к виджету (что особенно важно, если стоит галочка “Show widget Caption” - отображать подпись к виджету). 
И “Widget Id”, что будет полезно если вы просматриваете записи в формате JSON, отображающие структуру дашборда, в базе данных или JSON-файле. 
Параметры виджета - это набор дополнительных значений, передаваемых виджету, которые в дальнейшем сможет редактировать пользователь. 
Мы поговорим о них позже.
Редактор шаблонов виджетов позволяет сохранять настроенный виджет, то есть виджет с заранее заданными параметрами, в качестве шаблона для дальнейшего использования в других дашбордах. 
Окно адаптивных настроек используется для установки соотношения ширины виджетов в лейауте. 
И последнее окно - настройки стиля. Здесь можно определить стиль css для контейнера виджета и настроить его ширину и высоту. 
Окей, теперь мы знаем, как сделать простейший статичный виджет. 

## Updatable Widget

Но что, если нам нужно, чтобы виджет регулярно обновлялся? Например, мы хотим видеть рандомную шутку из интернета на дашборде, и чтобы она обновлялась каждые 15 секунд.
Хорошо, давайте выполним такую задачу, а заодно посмотрим на некоторые другие инструменты, предоставляемые дополнением Dashboards.
Создадим виджет, как мы делали до этого, и назовем его random-joke-widget. Добавим область textArea для шутки в xml-дескриптор и пропишем соответствующие атрибуты. Добавим аннотацию @DashboardWidget. Инжектируем textArea в класс-контроллер. Пусть контроллер виджета реализует интерфейс RefreshableWidget. 
Это интерфейс-маркер, который сообщает дополнению, что оно должно периодически вызывать метод refresh этого виджета. 
Окей, переопределим этот метод. И вызовем (пока пустой) метод с отображением новой шутки. Но как увидеть первую шутку? Как нам инициализировать виджет? В отличие от обычных экранов, аннотация @LoadDataBeforeShow не работает для виджетов дашборда. Как и обработка события Screen. 
BeforeShowEvent для него самого и для родительского экрана. Чтобы инициализировать виджет, нам нужно подписаться на InitEvent или AfterInitEvent. 
В нашем случае используем AfterInitEvent. Подпишемся на это событие и инициализируем в нем textArea. Теперь нам нужно получить саму шутку.
Используем сайт icanhazdadjoke.com для получения шуток. Документация находится здесь. 
Для выполнения задачи мы будем использовать класс RestTemplate из пакета org.springframework.web.client. Окей. Наш виджет с рандомными шутками, похоже, готов. 
Протестируем его. Добавим виджет на дашборд. Установим ширину и высоту. Работает! Но как установить период обновления? 
У нас есть поле под названием Refresh period, установим в нем период в 15 секунд. Этот метод обновления не вызывается в режиме редактирования дашборда. 
Чтобы обновления отображались, сохраним изменения и перейдем в режим просмотра дашборда. 
Видим, что шутки обновляются каждые 15 секунд. 

## Working with Data

Окей, этого хватит для создания простых виджетов, теперь создадим виджет, который будет работать с данными из базы данных. 
Виджет будет показывать календарь с отмеченными приемами в выбранном месяце. Добавим новый фрагмент экрана и назовем его visits-calendar-widget. 
Добавим аннотацию @DashboardWidget. Нам нужно работать с данными, поэтому добавим collectionContainer. Зададим ID   - visitsDс, класс - Visit, представление - “visit-with-pet”. 
Добавим загрузчик данных - dataLoader. Затем добавим vbox и Label,
datePicker для выбора отображаемого месяца и календарь в XML-дескриптор нашего фрагмента экрана. Теперь пора обновить класс-контроллер. 
Перейдем в виджет VisitsCalendarWidget и инжектируем наш dataLoader, DataContainer и Календарь.
Как вы помните, виджеты не могут загружать данные сами и аннотация @LoadDataBeforeShow с ними не работает.  
Поэтому нужно подписаться на событие onAfterInit и загружать данные туда.
Для этого будем вызывать метод load(). После этого также добавим приемы (Visits) в контроллер календаря в Java-коде. 
Также нам нужно обработать событие ValueChange, где мы установим начальную (startDate) и конечную (endDate)  даты календаря.
Теперь запустим приложение. Добавим “Visits Calendar” на наш тестовый дашборд и отрегулируем его размер. Можем убедиться, что наш виджет работает корректно. 

## Widget Parameters

Ранее мы отметили, что дополнение предоставляет редактор параметров, позволяющий создавать и передавать параметры виджету. 
Давайте посмотрим, как можно использовать эти параметры в нашем виджете. Предположим, мы хотим добавлять изображение покемона на дашборд. 
В этом демо мы будем брать картинки из ресурсов, однако, в реальном приложении эти изображения следует хранить в сущности Pet в поле с типом Файл. 
Добавим сначала собственный параметр для виджета Pokemon Art. Установим Value type - Entity, класс сущности - petclinic_Pet, алиас - pet, будем использовать алиас  для получения параметра в контроллере. Зададим для параметра произвольное имя. Выберем экземпляр сущности и представление. 
Окей, теперь наш виджет может получать параметр.
Посмотрим, как мы можем его использовать. Поместим изображения в папку, в которой лежит картинка с Пикачу. 
Теперь нам нужно создать поле класса с типом Pet, с таким же именем, каким мы ранее назвали алиас. Добавим аннотации  @WindowParam и @WidgetParam. 
Также инжектируем сам виджет, чтобы к нему тоже можно было добавить подпись. Ссылка на сущность Widget, которая технически является контейнером фрагмента экрана, передается как window param в контроллер фрагмента экрана. Доступ к сущностям Dashboard и DashboardFrame можно получить таким же способом.
Также нам нужно добавить компонент для изображений в наш контроллер через аннотацию @Inject. Осталось только немного доработать обработчик события onInit. 
Опять же, реализация довольно примитивна и не будет работать, если имя объекта Pet не совпадает с именем ресурса, или используется для загрузки неавторизованных ресурсов из папок.

Но она вполне подходит для демонстрации того, как передать параметры в виджеты. Проверим, как все работает. 
Мы видим, что картинка изменилась на покемона, установленного в параметрах.

## Custom Widget Editor

Думаю, вы заметили, что интерфейс настройки параметров виджетов не слишком удобный. В конце концов, откуда обычный пользователь может знать, какая сущность или список сущностей или перечисление нужно использовать в качестве параметра, и каковы допустимые значения для них? 
Давайте это исправим, а заодно и проблему с безопасностью и валидацией параметров, о которой мы говорили ранее. 
Это можно сделать с помощью настраиваемого редактора виджетов. Он предоставит лучший контроль передаваемых параметров, их валидации, а также даст конечному пользователю более удобный и дружелюбный интерфейс для настройки виджета. Создадим пустой фрагмент экрана и назовем его pokemon-art-widget-editor. 
Нужно убедиться, что он не назначен на какой-нибудь элемент веб-меню. Затем нам нужно добавить новое поле lookupField в лэйаут. 
Мы используем этот компонент для выбора картинки, которая будет отображаться в виджете. 
Уберем возможность установки пустого значения, чтобы пользователю приходилось выбирать картинку для отображения.
А также, если вы не сделали этого  ранее, добавьте message pack в пакет. Теперь перейдем в контроллер экрана и инжектируем LookupField, petName и petArtResource, добавим аннотации @WindowParam and @WidgetParam. Добавим несколько констант. Подпишимся на событие Init. Обработаем ValueChangeEvent. И реализуем метод listArtFiles. 
Теперь переключимся на PokemonArtWidget, откроем его класс-контроллер и укажем редактор виджета. 
Заменим инжектированный параметр сущности pet двумя новыми строковыми параметрами  - petName и petArtResource. 
Добавим аннотации @WindowParam и @WidgetParam и получим имя и ресурс с файлом из этих полей, если у них не нулевое значение. 
Теперь осталось только переписать метод onInit и добавить метод setPet. Взглянем на обновленный редактор виджетов. Настройка виджетов стала удобнее.

## Adding to the Main Screen

Добавить дашборд на экран довольно просто. Обычно дашборд размещают в приложении на главном экране. 
Посмотрим, как это сделать для приложения нашей ветеринарной клиники. Откроем окно дескриптора главного экрана - ext-mainwindow.xml. Прежде всего, нам нужно добавить пространство имен dashboards. Затем найти тег <main:workarea/>, который представляет область экрана, где приложение открывает экраны - там мы и будем размещать наш ранее созданный дашборд. 
Сначала нужно немного изменить лейаут рабочей области: добавить vBox, чтобы сообщить экрану, как разместить уже имеющуюся картинку и добавляемый дашборд. 
Затем добавим тег <dashboard:dashboard>, зададим ему ID и в атрибут кода передадим код созданного дашборда. 
В нашем случае это  “main-dashboard”. Параметр timer delay  играет ту же роль, что и refresh period  в редакторе дашборда, и переопределяет его, если прописаны оба. 
Теперь, когда настройка закончена, настало время запустить приложение и посмотреть на обновленный главный экран. Все работает как и задумано. 
Теперь на главном экране отображается дашборд.

## Dashboard Parameters

ано. Теперь на главном экране отображается дашборд. Теперь поговорим о параметрах дашборда. 
Эти параметры можно передать в дашборд либо с помощью тега <dashboard:parameter> в компоненте <dashboard::dashboard>, либо установив их в редакторе дашборда. 
Создадим параметр для главного дашборда в редакторе и установим алиас font-size (имя может быть любым) тип параметра STRING, а значение - huge.
Этот параметр будет передан всем виджетам дашборда, так что мы можем инжектировать его в наши виджеты с помощью аннотаций @WindowParam и @WidgetParam и использовать, как нам надо. Параметр инжектирован, как мы видели ранее, и используется в методе  onAfterInit. Посмотрим на результат. Размер шрифта в виджете изменился.

## Dashboard Assistant Bean

DashboardViewAssistant - это вспомогательный компонент, который используется для управления дашбордом. 
Это Spring-бин с областью видимости “prototype”, который получает управляемый экземпляр дашборда в свой метод init. 
В Dashboard Assistant удобно работать с бизнес-логикой дашбордов и виджетов. 
Так как пользователь может выбирать, какой assistant-бин привязать к  дашборду в пользовательском интерфейсе, assistant-бин очень полезен, если нужно, чтобы у пользователей была возможно включать и выключать часть бизнес-логики, или чтобы пользователь мог выбрать из заданных провайдеров бизнес-логики.
Создадим такой assistant bean. Сначала создадим пакет с именем assistant и класс VisitScheduleAssistant. 
Отметим его как компонент Spring с областью видимости “prototype” и укажем , что он реализует интерфейс DashboardViewAssistant.
Теперь переопределим метод init. Это довольно просто, достаточно сохранить объект дашборда для дальнейшего использования.
Окей, теперь наш помощник дашборда готов, но ничего не делает. Так что пора прописать его бизнес-логику. 
Здесь мы используем стандартный механизм событий Spring и подпишемся на DashboardUpdatedEvent - событие, которое дополнение посылает каждый раз, когда нужно обновить дашборд. Сначала нужно проверить ID виджета с календарем приемов. Это “visits-calendar”.
Теперь возьмем этот виджет из дашборда и вызовем для него метод reloadSchedule. Реализуем этот метод в VisitsCalendarWidget. 
Проведем рефакторинг и извлечем логику загрузки данных из метода onAfterInit. А затем улучшим ее с помощью загрузки посещений только для выбранного месяца. 
Для этого добавим общее условие к объявлению загрузчика данных в XML файле с двумя параметрами: start date (дата начала) и end date (дата окончания). 
Установим эти параметры для начальной и конечной даты календаря перед вызовом метода load(). 
Перезагрузим расписание для выбранного месяца в обработчике событий MonthPickerValueChange. Наш dashboard assistant готов, запустим приложение и проверим, как он работает. 
Откроем главный дашборд в редакторе, установим период обновления 30 секунд, и выберем assistant-бин, который только что создали. Сохраним изменения.
Посмотрим на календарь в главном окне. Создадим новый прием в месяце, выбранном на календаре. Через некоторое время вы увидим, что новый прием появился на календаре.

## Export and Import JSON files

И в завершении поговорим об импорте и экспорте JSON-файлов. Создадим новый дашборд и добавим в него виджет с изображением покемона.
Внизу экрана есть две кнопки. Экспортируем этот дашборд в файл JSON. Теперь можно использовать его в другом проекте или в этом же, создав новый дашборд и кликнув Import JSON. А теперь я покажу вам еще один способ добавления дашборда на главный экран. Поместим файл JSON в проект и укажем путь к нему в секции dashboard вместо кода. 

## Conclusion

Вот и все. Проверяем, что все работает. Как видите, мы сделали все, что было запланировано. Присоединяйтесь к сообществу и смело задавайте любые вопросы. Ответы на многие вопросы можно найти в документации на нашем сайте, а также на странице аддона. Скачивайте и используйте другие дополнения из каталога CUBA. Подписывайтесь на нас на GItHub, на наш Twitter и YouTube-канал! Все ссылки доступны под видео. Спасибо за просмотр!

