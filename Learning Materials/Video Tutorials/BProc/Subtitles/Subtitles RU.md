
# Бизнес-процессы в CUBA-приложениях

## Введение

Всем привет!

Сегодня мы покажем вам основные возможности дополнения BProc, а также расскажем, как моделировать и запускать бизнес-процессы в CUBA-приложениях. 

Бизнес-процессы - неотъемлемая часть многих корпоративных приложений. Дополнение позволяет описывать этапы процесса непосредственно в приложении с помощью интегрированного дизайнера. Который будучи частью приложения обеспечивает бесшовную интеграцию с исполняемыми частями приложения и визуальную настройку процесса.
Для исполнения бизнес-процессов дополнение BProc использует легковесный встраиваемый движок  Flowable.

Моделирование процессов осуществляется с помощью интегрированного в приложение визуального дизайнера, построенного на базе фреймворка bpmn.js. Процессы описываются с помощью нотации BPMN 2.0. В составе дополнения также поставляется редактор таблиц принятия решений, поддерживающий нотацию DMN 1.1.
Пользователи могут взаимодействовать с работающими экземплярами процесса через процессные формы. В простых случаях можно описать input-диалоги прямо в дизайнере процессов. 

Для сложных процессных форм можно использовать экраны, разработанные с помощью подсистемы Generic UI платформы CUBA.
Административные экраны для управления процессами позволяют просматривать все экземпляры запущенных процессов, переназначать задачи, анализировать историю выполнения процессов.

Также вы можете использовать API для работы с бизнес-процессами из кода.

## Демоприложение

А теперь посмотрим,  как использовать дополнение BProc в CUBA-приложении.

Вы возможно уже знакомы с нашим демоприложением petclinic, которое можно найти на сайте платформы CUBA. Оно демонстрирует IT-систему воображаемой ветеринарной клиники для покемонов и уже содержит данные о клиентах, питомцах, ветеринарах и приемах. Давайте придумаем бизнес-процесс для этого приложения.

Сначала взглянем на его исходную модель данных. Сущность Owner содержит данные о владельцах питомцев. Pet содержит имя, дату рождения и связана с классами Owner и PetType. Информация о приеме находится в классе Visit и относится к одному питомцу. Сущность Vet  отображает имена ветеринаров, расширяет класс Person  и связана с классом Spesialty.

Нам нужно добавить всего два атрибута к сущности Visit:
Статус - атрибут, который будет содержать текущий статус приёма.
И рекомендации - заметки ветеринара о приёме для владельца питомца.

Теперь посмотрим, что мы планируем реализовать в нашем демопроекте. Мы создадим бизнес-процесс, который запускается при создании администратором нового приема. Затем этот прием подтверждается или отменяется администратором. Главный врач должен выбрать ветеринара, который проведет прием или отменит его, если владелец питомца не придет. После создания процесса мы зайдем в CUBA Studio и реализуем процессные формы и сервис-таски. Потом мы завершим создание бизнес-процесса и развернём его. Нам останется только убедиться, что всё сделано правильно, и протестировать демопроект.

Итак, мы готовы начать. Зайдем в репозиторий Petclinic на github. Клонируем его и откроем проект в CUBA Studio.

Сначала нам нужно добавить в проект компонент BProc. Перейдем в marketplace и установим дополнение. Если у вас нет подписки, вы можете получить пробную версию BProc на странице дополнений на сайте платформы CUBA.

## Расширение модели данных

Прежде чем начать моделировать бизнес-процесс, расширим модель данных.

Перейдем к сущности Visit и переключИмся на дизайнер. Добавим два атрибута строкового типа: status и recommendations с неограниченной длиной. Других изменений в модели данных не требуется.

Мы почти готовы, осталось немного обновить экраны просмотра и редактирования. Перейдем в дескриптор экрана просмотра сущности Visit и переключимся на дизайнер. Выберем таблицу visitsTable и добавим еще одну колонку с атрибутом статус.

Затем перейдем в редактор сущности Visit и добавим поле статус. Нам не нужно изменять это свойство при создании или редактировании приемов, так что сделаем его нередактируемым. То же самое сделаем для поля рекомендЭйшенс.

Вот и все. Теперь создадим базу данных. Идем в меню CUBA -> Generate database scripts и нажмем Create database. Подтвердим перезапись существующих скриптов.

## Моделирование бизнес-процесса

Итак, мы завершили все приготовления и можем начать моделирование бизнес-процесса.

Запустим приложение и перейдем по ссылке. Войдем в приложение с логином и паролем - админ. Мы предполагаем, что пользователь администратор - это администратор клиники, который регистрирует и подтверждает приемы. Мы заранее добавили трех новых пользователей. Это пользователь с ролью чиф - главный ветеринар. И два пользователя с ролью Vet.
Как видите, в меню появился раздел BProc. Развернем его и выберем Modeler. Область для рисования содержит только элемент start event. Справа находится панель свойств процесса. Зададим ID процесса. Он понадобится нам в коде.

Как мы помним, процесс будет включать трех участников. Поместим на рабочее поле элемент pool и разделим его на три дорожки. Это позволит нам назначать исполнителя не на каждую задачу, а на задачи конкретной дорожки. Выберем первую дорожку и назовем ее администратор. 

Вторая дорожка будет называться Chief Vet - главный ветеринар, а третья - Vet. Исполнителей мы укажем позже.
Процесс будет запускаться при создании каждого нового приема без участия пользователя. Выберем на рабочей области элемент Start event и оставим свойство No form.
Добавим две процессные переменные: Visit с типом entity и администратор с типом user. Используем эти переменные в процессе позже. 

Будем запускать процесс автоматически из кода и записывать новый прием в переменную Visit, а пользователя, создавшего прием, в переменную администратор.
Будем считать, что администратор должен подтвердить задачу за день до приема. Поэтому добавим таймер. Таймер - это промежуточное событие, работающее по принципу секундомера. Когда выполнение процесса достигает данного элемента, запускается таймер. Когда таймер срабатывает, процесс переходит по стрелке к следующему элементу. 

В контекстном меню выберем элемент Append Intermediate и изменим его тип на Timer Intermediate Catch Event. Установим тип таймера Date и пропишем в выражение процессную переменную confirmVisitDate. Определим эту переменную в коде при запуске процесса.

За день до приема администратор, который создал прием, должен получить задачу и подтвердить или отменить ее. Используем элемент таск. Назовем его Confirm the Visit и определим как User task.  Тип формы: input dialog. Диалог будет отображать два поля, в которые мы и поместим процессные переменные. Первая - уже существующая переменная Visit, сделаем ее нередактируемой. И еще одна, новая - комментарий владельца, со строковым типом неограниченной длины. Сделаем ее редактируемой.

На этом этапе у администратора есть два варианта: подтвердить или отменить прием. Проще всего реализовать это через элемент outcome - итоговый результат. Для каждого outcome в форме будет отображаться кнопка, а результат сохраняться в специальной процессной переменной. 

Создадим новый outcome с помощью соответствующей кнопки в разделе outcome. С помощью редактора определим ID и подпись  - confirm - и выберем иконку Check из списка.
Второй outcome - cancel, выберем иконку Ban.

Затем добавим элемент gateway. Он используется для моделирования ветвления в процессе. Из gateway будут выходить два потока: один для пользовательской задачи и другой - для сервисной.

Для первой задачи зададим имя Select a Vet. Изменим тип элемента на User task. Выберем поток, установим для него outcome -  confirm - и назовем его confirm. После того, как администратор подтвердит прием, главный ветеринар получит этот User task.

Зададим имя второй задачи. Эта задача будет присваивать приему статус canceled - отменен. Изменим тип элемента на Service task. Для задачи, которая меняет статус Visit, будем использовать Spring bean. Мы настроим его позже после создания в коде. Выберем поток и назовем его canceled. Выберем outcome - cancel. 
После выполнения этой сервисной задачи бизнес-процесс для конкретного Visitа заканчивается. Добавим завершающий элемент - End event.

Теперь мы можем установить исполнителя для первой дорожки. Выберем ее  и установим  Process variable - администратор. Это процессная переменная, полученная после создания нового Visit.

Для пользовательской задачи выберем тип формы: input dialog. Добавим переменные, которые будут отображаться в диалоге для главного ветеринара: 
существующие переменные - Visit и Owner comment и добавим новую переменную - Vet - с типом user. Сделаем ее редактируемой и обязательной. Выберем UI компонент для этого поля - LookupField. И введем запрос, который выбирает из базы данных всех пользователей с ролью ветеринар.

Настроим тип исполнителя для второй дорожки с пользовательской задачей. Выберем дорожку и определим тип исполнителя - UserProvider. Позже мы создадим класс, который будет программно выбирать главного ветеринара.  

На следующем этапе выбранный ветеринар получит задачу. Добавим User task и назовем его Visit. В качестве формы, которая будет показана ветеринару, мы используем CUBA screen. Экран ещё не создан, мы сможем выбрать его в выпадающем списке после создания. Задаваемые формой процессные переменные и outcomes мы определим в коде экрана. Они появятся в списке после выбора созданного экрана на панели свойств.

На этом этапе у ветеринара есть два варианта действий: завершить прием, если он состоялся, или отклонить, если пациент не пришел. 

Снова добавляем элемент gateway. Первый поток - это сервисная задача, устанавливающая статус Patient did not come. Зададим имя потока. У нас появится возможность выбирать результат, когда будет установлен CUBA screen для предшествующей пользовательской задачи. Используем такой же Spring bean, как для сервисной задачи,  устанавливающей статус canceled. И его также настроим после создания в коде.

Второй поток ведет к сервисной задаче, которая завершает Visit. Используем для этой задачи класс JavaDelegate. Этот класс будет сохранять рекомендации ветеринара, устанавливать статус приема и отправлять имэйл владельцу.

Установим имя потока - Completed. Добавим два завершающих элемента.
Добавим еще один таймер. В случае, если прием просрочен на один день, статус приема автоматически изменится на Patient did not come - пациент не пришел. Нам нужно добавить Boundary event и изменить тип на Timer Boundary Event. Определим в выражении процессную переменную Overdue Visit Date.

Зададим имя потока.
Осталось только определить исполнителя для третьей дорожки - это процессная переменная - Vet.
Окей, мы создали бизнес-процесс и готовы заняться кодом. Сохраним модель как черновик. Внесем последние изменения в модель после добавления нужного кода. 

## Запуск процесса из кода

Начнем со старта процесса.
Перейдем в CUBA Studio и откроем контроллер экрана редактора приема. Нам понадобятся две постоянных: ID бизнес-процесса и статус нового Visitа.
Подпишемся на событие InitEntity. В теле установим статус для нового приема, а для переменной, указывающей, что сущность - новая, установим значение true.
Теперь подпишемся на событие AfterCommitChangesEvent. Получим отредактированный прием и, если он новый, запустим процесс. 

Определим процессные переменные в виде пары: строковое имя - значение:

* новый прием
* пользователь, создавший прием
* две даты:
* при создании бизнес-процесса мы говорили, что для первого таймера датой будет служить день, предшествующий дню приема. Но чтобы можно было наблюдать за процессом в работе, установим таймер на текущую дату плюс пять секунд. Таким образом, задача появится в списке задач администратора через пять секунд после создания приема;
* а также дата просрочки приема. Это дата приема плюс один день. 

Для запуска процесса используем BProcRuntimeService. Зададим ProcessDefinitionKey, Instance Name в качестве дополнительного  бизнес-ключа и процессные переменные.
На этом все. При каждом создании приема будет запускаться бизнес-процесс.

## User Provider

Следующим шагом будет создание Spring bean, который реализует интерфейс UserProvider. 

Мы используем этот бин во второй дорожке нашей модели, чтобы задача автоматически назначалась на главного ветеринара. Интерфейс содержит get-метод, возвращающий пользователя, который должен быть назначен как исполнитель задачи.
Создадим новый бин под названием ChiefVetUserProvider. Он реализует интерфейс UserProvider.

Добавим постоянную, хранящую имя роли пользователя.

Теперь нам нужно переопределить метод get. В теле метода получаем список пользователей с ролью Chief. Используем для загрузки данных DataManager, в качестве параметра возьмем постоянную с именем роли.

Если список пользователей пуст, будет возвращаться исключение с соответствующим сообщением. Если нет, то первый пользователь из списка. 
User provider готов.

## CUBA Screen

В качестве формы для пользовательской задачи, которую получает ветеринар, мы планировали использовать CUBA screen.
Перейдем в дереве проекта на скринс и создадим новый пустой экран. Нужно убедиться, что он не назначен на элементы вэб-меню. Назовем его Visit. 
Переключимся на дизайнер и смоделируем экран.

Добавим компонент форм, поместим PickerField и два компонента TextArea на форму. 
Зададим ID и подпись для PickerField  - Visit. Метакласс - Visit. Сделаем его нередактируемым.
В первом текстовом поле будет отображаться комментарий владельца. Сделаем его нередактируемым.
Второе текстовое поле - для рекомендаций ветеринара. Оставим его редактируемым.

Теперь добавим hbox и разместим в нем две кнопки.
Зададим подписи к кнопкам и ID. Одна используется для завершения состоявшегося приема и вторая для случая, когда клиент не пришел.
Теперь перейдем в контроллер. Сначала добавим две постоянных со статусами приема. 
Теперь к экрану нужно добавить аннотацию ProcessForm, чтобы использовать экран как процессную форму. Потом экран будет отображаться в списке процессных форм в дизайнере.

Объявим два outcome, которые будем использовать для потоков в дизайнере. Используем атрибут outcomes аннотации ProcessForm.
Инжектируем TextAreas и PickerField. Добавим аннотацию Process variable, чтобы объявить, что инжектированный компонент - это процессная переменная. Значения Visit и OwnersComment уже определены в процессе, так что в отображаемой форме они появятся в соответствующих полях. Значение переменной recommendations еще не задано, но аннотация Process variable будет учтена  во время завершения задачи.

Инжектируем ProcessFormContext, который содержит информацию о пользовательской задаче и методы для завершения задачи.
Теперь нам нужно обработать ClickEvents. Подпишемся на событие visitCompletedBtn. Создадим экземпляр TaskCompetion. Настроим outcome. Обозначим, что значения полей класса, аннотированных как ProcessVariables, должны собираться и храниться как процессные переменные. Завершаем задачу.

Подпишемся на событие PatientDidNotComeBtn. Настроим соответствующий outcome. Теперь мы пойдем другим путем, и вместо вызова метода saveInjectedProcessVariables определим переменные напрямую.
На этом настройка экрана CUBA завершена.

## Service Tasks

Наконец, добавим сервисные задачи. 
Нам нужно, чтобы процесс автоматически завершался, когда прием состоялся или администратор его отменил. Единственное, что нам нужно сделать до завершения задачи - установить соответствующий статус приема. Создадим простой бин с методом setStatus, который в качестве параметров получает прием и строку с его статусом.
Инжектируем DataManager. В теле метода перезагрузим Visit, установим статус и сохраним изменения. На этом все. 

Вторая сервисная задача завершает процесс после окончания приема. Для этой цели мы используем JavaDelegate. В core-модуле создадим новый класс. Он должен реализовывать интерфейс JavaDelegate, который требует реализации метода execute. Он вызывается каждый раз, когда процесс достигает сервисной задачи.
Объявим поле expression, определенное в модели процесса. И добавим постоянную со статусом completed.

Получим процессные переменные: Visit и recommendations.
И нам нужно перезагрузить переменную Visit, в ней должна содержаться  информация о владельце и его имейле. Создадим новое представление.

Установим статус и рекомендации для приема и сохраним эти данные.

Чтобы отправить письмо владельцу, возьмем адрес его электронной почты. И получим строковое представление шаблона письма. Затем вызовем метод sendEmail. У нас нет задачи отправить реальное письмо, поэтому в теле метода sendEmail запишем сообщение в файл с логами.

Мы сделали в коде все, что планировали. 

## Тестирование демоприложения

Теперь закончим моделирование бизнес-процесса и проверим его в работе. Запустим приложение, войдем как администратор и перейдем на экран дизайнера.

Откроем модель бизнес-процесса из черновика. Настроим Spring bean для сервисной задачи Set status canceled и передадим ему в качестве параметров процессную переменную Visit и статус canceled. То же самое сделаем для задачи  Set status Patient did not come, но передадим другой соответствующий статус.
Теперь можно настроить UserProvider для второй дорожки.

Для пользовательской задачи Visit выберем созданный CUBA-экран. Мы видим, что outcomes появились в свойствах задачи. Теперь установим outcomes для соответствующих элементов “поток”.
И установим класс JavaDelegate.

Теперь наша модель готова к развертыванию. После этого описание процесса будет доступно на экране Process definition. Его можно открыть в дизайнере и обновить или просмотреть детали в экране редактора.

Протестируем созданный процесс. Перейдем в браузер приемов и создадим три новых приема. Теперь мы видим приемы без статуса, созданные вместе с базой,  и три новых приема со статусом New.
Перейдем на экран My tasks. Первый таймер установлен на текущую дату плюс пять секунд, так что администратор уже увидел эти приемы и может их подтвердить или отменить.

Отменим первый прием. Перейдем в браузер приемов. У отмененного приема появился соответствующий статус.
Теперь подтвердим остальные приемы. Добавим информацию в поле для комментария владельца. Главный ветеринар получил задачи. Перейдем в аккаунт с ролью Chief, пароль и логин одинаковые. Главный ветеринар должен назначить приемы ветеринарам. 

Перейдем в аккаунт ветеринара, пароль и логин одинаковые. У ветеринара появилось два приема. Откроем первый. Вот созданный нами ранее CUBA screen. Теперь поле с комментарием пользователя стало нередактируемым. Напишем несколько рекомендаций и нажмем Visit completed. В этот момент вызывается метод execute класса JavaDelegate. Просмотрим логи и убедимся, что он работает корректно.

И наконец проверим ситуацию, в которой клиент не пришел. Откроем последний прием и нажмем кнопку Patient did not come. Перейдем в браузер приемов и проверим статусы приемов. Все записи соответствуют результату 

Убедимся, что все экземпляры процесса завершены, перейдем на экран экземпляров процесса и найдем активные. Список пуст - значит, наш бизнес-процесс и его код работают как надо!


## Заключение

Итак, мы сделали все, что планировали. Присоединяйтесь к сообществу и смело задавайте любые вопросы. 

Скачивайте и используйте другие дополнения из каталога CUBA. Ответы на многие вопросы можно найти в документации на нашем сайте. Подписывайтесь на нас на github, на наш twitter и youtube-канал! Все ссылки доступны под видео. Спасибо за просмотр!
