1
00:00:00,266 --> 00:00:04,632
Всем привет! Сегодня мы покажем вам основные возможности дополнения BProc, 

2
00:00:04,633 --> 00:00:08,999
а также расскажем, как моделировать и запускать бизнес-процессы в CUBA-приложениях. 

3
00:00:10,166 --> 00:00:14,032
Бизнес-процессы - неотъемлемая часть многих корпоративных приложений.

4
00:00:14,033 --> 00:00:19,966
Дополнение позволяет описывать этапы процесса непосредственно в приложении с помощью интегрированного дизайнера. 

5
00:00:19,966 --> 00:00:23,599
Который будучи частью приложения обеспечивает бесшовную интеграцию 

6
00:00:23,600 --> 00:00:27,900
с исполняемыми частями приложения и визуальную настройку процесса.

7
00:00:29,066 --> 00:00:35,299
Для исполнения бизнес-процессов дополнение BProc использует легковесный встраиваемый движок  Flowable.

8
00:00:35,733 --> 00:00:40,966
Моделирование процессов осуществляется с помощью интегрированного в приложение визуального дизайнера, 

9
00:00:40,966 --> 00:00:44,599
построенного на базе фреймворка bpmn-js. 

10
00:00:44,600 --> 00:00:48,633
Процессы описываются с помощью нотации BPMN 2.0. 

11
00:00:48,633 --> 00:00:52,766
В составе дополнения также поставляется редактор таблиц принятия решений, 

12
00:00:52,766 --> 00:00:56,066
поддерживающий нотацию DMN 1.1.

13
00:00:56,066 --> 00:01:01,099
Пользователи могут взаимодействовать с работающими экземплярами процесса через процессные формы. 

14
00:01:01,100 --> 00:01:06,033
В простых случаях можно описать input-диалоги прямо в дизайнере процессов. 

15
00:01:06,033 --> 00:01:09,099
Для сложных процессных форм можно использовать экраны, 

16
00:01:09,100 --> 00:01:12,900
разработанные с помощью подсистемы Generic UI платформы CUBA.

17
00:01:12,900 --> 00:01:16,933
Административные экраны для управления процессами позволяют просматривать 

18
00:01:16,933 --> 00:01:21,966
все экземпляры запущенных процессов, переназначать задачи, анализировать историю выполнения процессов.

19
00:01:21,966 --> 00:01:26,266
Также вы можете использовать API для работы с бизнес-процессами из кода.

20
00:01:27,300 --> 00:01:31,666
А теперь посмотрим,  как использовать дополнение BProc в CUBA-приложении.

21
00:01:31,666 --> 00:01:35,532
Вы возможно уже знакомы с нашим демоприложением petclinic, 

22
00:01:35,533 --> 00:01:37,799
которое можно найти на сайте платформы CUBA. 

23
00:01:37,800 --> 00:01:42,333
Оно демонстрирует IT-систему воображаемой ветеринарной клиники для покемонов 

24
00:01:42,333 --> 00:01:47,399
и уже содержит данные о клиентах, питомцах, ветеринарах и приемах. 

25
00:01:47,400 --> 00:01:50,400
Давайте придумаем бизнес-процесс для этого приложения.

26
00:01:50,400 --> 00:01:53,500
Сначала взглянем на его исходную модель данных. 

27
00:01:53,500 --> 00:01:57,366
Сущность Owner содержит данные о владельцах питомцев. 

28
00:01:57,366 --> 00:02:02,766
Pet содержит имя, дату рождения и связана с классами Owner и PetType. 

29
00:02:02,766 --> 00:02:07,566
Информация о приеме находится в классе Visit и относится к одному питомцу. 

30
00:02:07,566 --> 00:02:10,399
Сущность Vet  отображает имена ветеринаров, 

31
00:02:10,400 --> 00:02:14,033
расширяет класс Person  и связана с классом Specialty.

32
00:02:18,633 --> 00:02:21,966
Нам нужно добавить всего два атрибута к сущности Visit:

33
00:02:21,966 --> 00:02:26,266
Статус - атрибут, который будет содержать текущий статус приёма.

34
00:02:26,266 --> 00:02:30,932
И рекомендации - заметки ветеринара о приёме для владельца питомца.

35
00:02:30,933 --> 00:02:34,999
Теперь посмотрим, что мы планируем реализовать в нашем демопроекте. 

36
00:02:35,000 --> 00:02:40,633
Мы создадим бизнес-процесс, который запускается при создании администратором нового приема. 

37
00:02:40,633 --> 00:02:44,933
Затем этот прием подтверждается или отменяется администратором. 

38
00:02:44,933 --> 00:02:46,833
Главный врач должен выбрать ветеринара, 

39
00:02:46,833 --> 00:02:51,133
который проведет прием или отменит его, если владелец питомца не придет. 

40
00:02:51,133 --> 00:02:56,966
После создания процесса мы зайдем в CUBA Studio и реализуем процессные формы и сервис-таски. 

41
00:02:56,966 --> 00:03:00,732
Потом мы завершим создание бизнес-процесса и развернём его. 

42
00:03:00,733 --> 00:03:05,266
Нам останется только убедиться, что всё сделано правильно, и протестировать демопроект.

43
00:03:07,066 --> 00:03:12,266
Итак, мы готовы начать. 
Зайдем в репозиторий petclinic на github. 

44
00:03:12,266 --> 00:03:15,799
Клонируем его и откроем проект в CUBA Studio.

45
00:03:21,533 --> 00:03:25,233
Сначала нам нужно добавить в проект компонент BProc. 

46
00:03:25,233 --> 00:03:28,233
Перейдем в Marketplace и установим дополнение. 

47
00:03:28,233 --> 00:03:36,699
Если у вас нет подписки, вы можете получить пробную версию BProc на странице дополнений на сайте платформы CUBA.

48
00:03:36,700 --> 00:03:40,500
Прежде чем начать моделировать бизнес-процесс, расширим модель данных.

49
00:03:43,266 --> 00:03:48,866
Перейдем к сущности Visit и переключимся на дизайнер. 

50
00:03:48,866 --> 00:03:51,899
Добавим два атрибута строкового типа: 

51
00:03:51,900 --> 00:03:56,466
status и recommendations с неограниченной длиной. 

52
00:03:58,800 --> 00:04:01,533
Других изменений в модели данных не требуется.

53
00:04:01,533 --> 00:04:07,033
Мы почти готовы, осталось немного обновить экраны просмотра и редактирования. 

54
00:04:07,033 --> 00:04:12,266
Перейдем в дескриптор экрана просмотра сущности Visit и переключимся на дизайнер. 

55
00:04:12,266 --> 00:04:17,499
Выберем таблицу visitsTable и добавим еще одну колонку с атрибутом статус.

56
00:04:22,400 --> 00:04:26,766
Затем перейдем в редактор сущности Visit и добавим поле статус.

57
00:04:26,766 --> 00:04:30,999
Нам не нужно изменять это свойство при создании или редактировании приемов, 

58
00:04:31,000 --> 00:04:33,333
так что сделаем его нередактируемым. 

59
00:04:33,333 --> 00:04:36,299
То же самое сделаем для поля recommendations.

60
00:04:36,300 --> 00:04:38,700
Вот и все. Теперь создадим базу данных. 

61
00:04:38,700 --> 00:04:44,833
Идем в меню CUBA -> Generate database scripts и нажимаем Create database. 

62
00:04:44,833 --> 00:04:47,399
Подтвердим перезапись существующих скриптов.

63
00:04:51,366 --> 00:04:56,532
Итак, мы завершили все приготовления и можем начать моделирование бизнес-процесса.

64
00:04:59,166 --> 00:05:04,299
Запустим приложение и перейдем по ссылке. 

65
00:05:04,300 --> 00:05:07,733
Войдем в приложение с логином и паролем - админ. 

66
00:05:07,733 --> 00:05:11,799
Мы предполагаем, что пользователь администратор - это администратор клиники, 

67
00:05:11,800 --> 00:05:14,300
который регистрирует и подтверждает приемы. 

68
00:05:14,300 --> 00:05:16,566
Мы заранее добавили трех новых пользователей. 

69
00:05:16,566 --> 00:05:23,099
Это пользователь с ролью Chief - главный ветеринар. И два пользователя с ролью Vet.

70
00:05:23,100 --> 00:05:25,700
Как видите, в меню появился раздел BProc. 

71
00:05:25,700 --> 00:05:27,900
Развернем его и выберем Modeler. 

72
00:05:27,900 --> 00:05:31,866
Область для рисования содержит только элемент StartEvent. 

73
00:05:31,866 --> 00:05:36,132
Справа находится панель свойств процесса. Зададим ID процесса. 

74
00:05:36,133 --> 00:05:37,733
Он понадобится нам в коде.

75
00:05:42,700 --> 00:05:45,700
Как мы помним, процесс будет включать трех участников. 

76
00:05:45,700 --> 00:05:52,566
Поместим на рабочее поле элемент “пул” и разделим его на три дорожки. 

77
00:05:52,566 --> 00:05:56,032
Это позволит нам назначать исполнителя не на каждую задачу, 

78
00:05:56,033 --> 00:05:58,266
а на задачи конкретной дорожки. 

79
00:05:58,266 --> 00:06:01,599
Выберем первую дорожку и назовем ее администратор. 

80
00:06:05,400 --> 00:06:10,900
Вторая дорожка будет называться Chief Vet - главный ветеринар, а третья - Vet. 

81
00:06:10,900 --> 00:06:12,600
Исполнителей мы укажем позже.

82
00:06:12,600 --> 00:06:17,800
Процесс будет запускаться при создании каждого нового приема без участия пользователя. 

83
00:06:17,800 --> 00:06:23,300
Выберем на рабочей области элемент StartEvent и оставим свойство No form.

84
00:06:23,300 --> 00:06:27,500
Добавим две процессные переменные: 

85
00:06:27,500 --> 00:06:37,900
Visit с типом entity и администратор с типом user. 

86
00:06:37,900 --> 00:06:41,033
Используем эти переменные в процессе позже. 

87
00:06:41,033 --> 00:06:46,566
Будем запускать процесс автоматически из кода и записывать новый прием в переменную Visit, 

88
00:06:46,566 --> 00:06:50,699
а пользователя, создавшего прием, в переменную администратор.

89
00:06:50,700 --> 00:06:55,033
Будем считать, что администратор должен подтвердить задачу за день до приема. 

90
00:06:55,033 --> 00:06:58,733
Поэтому добавим таймер. Таймер - это промежуточное событие, 

91
00:06:58,733 --> 00:07:00,933
работающее по принципу секундомера. 

92
00:07:00,933 --> 00:07:05,066
Когда выполнение процесса достигает данного элемента, запускается таймер. 

93
00:07:05,066 --> 00:07:09,766
Когда таймер срабатывает, процесс переходит по стрелке к следующему элементу. 

94
00:07:09,766 --> 00:07:13,232
В контекстном меню выберем элемент Append Intermediate

95
00:07:13,233 --> 00:07:18,633
и изменим его тип на Timer Intermediate Catch Event. 

96
00:07:18,633 --> 00:07:24,799
Установим тип таймера Date и пропишем в выражение процессную переменную confirmVisitDate. 

97
00:07:24,800 --> 00:07:29,233
Определим эту переменную в коде при запуске процесса.

98
00:07:29,233 --> 00:07:32,299
За день до приема администратор, который создал прием, 

99
00:07:32,300 --> 00:07:37,300
должен получить задачу и подтвердить или отменить ее. 

100
00:07:37,300 --> 00:07:42,000
Используем элемент таск. 

101
00:07:42,000 --> 00:07:47,533
Назовем его Confirm the Visit и определим как юзер-таск.  

102
00:07:47,533 --> 00:07:54,033
Тип формы: input dialog. Диалог будет отображать два поля, в которые мы и поместим процессные переменные. 

103
00:07:54,033 --> 00:08:03,766
Первая - уже существующая переменная Visit, сделаем ее нередактируемой. 

104
00:08:03,766 --> 00:08:09,366
И еще одна, новая - комментарий владельца, со строковым типом неограниченной длины. 

105
00:08:09,366 --> 00:08:11,732
Сделаем ее редактируемой.

106
00:08:11,733 --> 00:08:16,833
На этом этапе у администратора есть два варианта: подтвердить или отменить прием. 

107
00:08:16,833 --> 00:08:21,266
Проще всего реализовать это через элемент ауткам - итоговый результат. 

108
00:08:21,266 --> 00:08:24,866
Для каждого ауткама в форме будет отображаться кнопка, 

109
00:08:24,866 --> 00:08:27,832
а результат сохраняться в специальной процессной переменной. 

110
00:08:27,833 --> 00:08:32,766
Создадим новый ауткам с помощью соответствующей кнопки в разделе Outcomes. 

111
00:08:32,766 --> 00:08:41,466
С помощью редактора определим ID и подпись confirm и выберем иконку CHECK из списка.

112
00:08:41,466 --> 00:08:47,799
Второй ауткам - cancel, выберем иконку BAN.

113
00:08:47,800 --> 00:08:50,366
Затем добавим элемент Gateway. 

114
00:08:50,366 --> 00:08:53,532
Он используется для моделирования ветвления в процессе. 

115
00:08:53,533 --> 00:08:59,633
Из Gateway будут выходить два потока: один для пользовательской задачи и другой - для сервисной.

116
00:08:59,633 --> 00:09:04,233
Для первой задачи зададим имя Select a Vet. 

117
00:09:04,233 --> 00:09:15,233
Заменим тип элемента на User Task, выберем поток, установим для него ауткам сonfirm и назовем его Confirm. 

118
00:09:15,233 --> 00:09:20,899
После того, как администратор подтвердит прием, главный ветеринар получит этот User Task.

119
00:09:20,900 --> 00:09:23,266
Зададим имя второй задачи.

120
00:09:23,266 --> 00:09:27,132
Эта задача будет присваивать приему статус Canceled - отменен. 

121
00:09:27,133 --> 00:09:29,799
Изменим тип элемента на Service Task. 

122
00:09:29,800 --> 00:09:33,933
Для задачи, которая меняет статус визита, будем использовать Spring bean. 

123
00:09:33,933 --> 00:09:37,199
Мы настроим его позже после создания в коде. 

124
00:09:37,200 --> 00:09:41,066
Выберем поток и назовем его Canceled. 

125
00:09:41,066 --> 00:09:43,466
Выберем ауткам - Cancel. 

126
00:09:43,466 --> 00:09:48,599
После выполнения этой сервисной задачи бизнес-процесс для конкретного визита заканчивается. 

127
00:09:48,600 --> 00:09:51,733
Добавим завершающий элемент - end event.

128
00:09:51,733 --> 00:09:55,733
Теперь мы можем установить исполнителя для первой дорожки. 

129
00:09:55,733 --> 00:10:00,566
Выберем ее  и установим  process variable - > administrator. 

130
00:10:00,566 --> 00:10:04,232
Это процессная переменная, полученная после создания нового Visitа.

131
00:10:04,233 --> 00:10:09,766
Для пользовательской задачи выберем тип формы:  input dialog. 

132
00:10:09,766 --> 00:10:14,366
Добавим переменные, которые будут отображаться в диалоге для главного ветеринара: 

133
00:10:14,366 --> 00:10:22,932
существующие переменные - Visit и ownersComment

134
00:10:22,933 --> 00:10:27,499
и добавим новую переменную vet с типом user. 

135
00:10:27,500 --> 00:10:30,433
Сделаем ее редактируемой и обязательной. 

136
00:10:30,433 --> 00:10:33,766
Выберем UI компонент для этого поля - LookupField. 

137
00:10:33,766 --> 00:10:40,966
И введем запрос, который выбирает из базы данных всех пользователей с ролью ветеринар.
 

138
00:10:40,966 --> 00:10:44,866
Настроим тип исполнителя для второй дорожки с пользовательской задачей. 

139
00:10:44,866 --> 00:10:49,332
Выберем дорожку и определим тип исполнителя - User Provider. 

140
00:10:49,333 --> 00:10:53,866
Позже мы создадим класс, который будет программно выбирать главного ветеринара.  

141
00:10:53,866 --> 00:10:57,199
На следующем этапе выбранный ветеринар получит задачу. 

142
00:10:57,200 --> 00:11:00,433
Добавим  User Task и назовем его Visit. 

143
00:11:00,433 --> 00:11:04,833
В качестве формы, которая будет показана ветеринару, мы используем CUBA-скрин. 

144
00:11:04,833 --> 00:11:09,766
Экран ещё не создан, мы сможем выбрать его в выпадающем списке после создания. 

145
00:11:09,766 --> 00:11:15,099
Задаваемые формой процессные переменные и ауткамы мы определим в коде экрана. 

146
00:11:15,100 --> 00:11:19,466
Они появятся в списке после выбора созданного экрана на панели свойств.

147
00:11:19,466 --> 00:11:22,499
На этом этапе у ветеринара есть два варианта действий: 

148
00:11:22,500 --> 00:11:27,933
завершить прием, если он состоялся, или отклонить, если пациент не пришел.

149
00:11:27,933 --> 00:11:30,666
Снова добавляем элемент Gateway. 

150
00:11:30,666 --> 00:11:35,832
Первый поток - это сервисная задача, устанавливающая статус Patient did not come. 

151
00:11:45,533 --> 00:11:49,466
Зададим имя потока. 

152
00:11:49,466 --> 00:11:56,366
У нас появится возможность выбирать результат, когда будет установлен CUBA-скрин для предшествующей пользовательской задачи. 

153
00:11:56,366 --> 00:12:01,999
Используем такой же Spring bean, как для сервисной задачи,  устанавливающей статус canceled. 

154
00:12:02,000 --> 00:12:05,300
И его также настроим после создания в коде.

155
00:12:05,300 --> 00:12:08,933
Второй поток ведет к сервисной задаче, которая завершает Visit. 

156
00:12:19,266 --> 00:12:22,666
Используем для этой задачи класс Java Delegate. 

157
00:12:22,666 --> 00:12:30,532
Этот класс будет сохранять рекомендации ветеринара, устанавливать статус приема и отправлять email владельцу.

158
00:12:30,533 --> 00:12:35,166
Установим имя потока - Completed. 

159
00:12:35,166 --> 00:12:41,499
Добавим два завершающих элемента.

160
00:12:41,500 --> 00:12:43,100
Добавим еще один таймер. 

161
00:12:43,100 --> 00:12:49,033
В случае, если прием просрочен на один день, статус приема автоматически изменится на Patient did not come - 

162
00:12:49,033 --> 00:12:50,266
пациент не пришел. 

163
00:12:52,433 --> 00:12:59,166
Нам нужно добавить Boundary event и изменить тип на Timer Boundary Event. 

164
00:12:59,166 --> 00:13:05,966
Определим в выражении процессную переменную overdueVisitDate.

165
00:13:05,966 --> 00:13:09,999
Зададим имя потока.

166
00:13:10,000 --> 00:13:16,833
Осталось только определить исполнителя для третьей дорожки - это процессная переменная - Vet.

167
00:13:16,833 --> 00:13:20,433
Окей, мы создали бизнес-процесс и готовы заняться кодом. 

168
00:13:20,433 --> 00:13:22,199
Сохраним модель как черновик. 

169
00:13:22,200 --> 00:13:25,733
Внесем последние изменения в модель после добавления нужного кода. 

170
00:13:28,066 --> 00:13:32,766
Начнем со старта процесса

171
00:13:32,766 --> 00:13:37,032
Перейдем в CUBA-Studio и откроем контроллер экрана редактора приема. 

172
00:13:37,033 --> 00:13:50,666
Нам понадобятся две постоянных: ID бизнес-процесса и статус нового визита.

173
00:13:50,666 --> 00:13:55,399
Подпишемся на событие InitEntity. 

174
00:13:55,400 --> 00:14:01,833
В теле установим статус для нового приема, 

175
00:14:01,833 --> 00:14:10,033
а для переменной, указывающей, что сущность - новая, установим значение true.

176
00:14:10,033 --> 00:14:18,499
Теперь подпишемся на событие AfterCommitChangesEvent. 

177
00:14:18,500 --> 00:14:24,866
Получим отредактированный прием и, если он новый, запустим процесс.  

178
00:14:24,866 --> 00:14:33,266
Определим процессные переменные в виде пары: строковое имя - значение:

179
00:14:33,266 --> 00:14:57,866
новый прием, пользователь, создавший прием

180
00:14:57,866 --> 00:14:59,399
и две даты:

181
00:14:59,400 --> 00:15:02,766
при создании бизнес-процесса мы говорили, что для первого таймера  

182
00:15:02,766 --> 00:15:05,532
датой будет служить день, предшествующий дню приема. 

183
00:15:05,533 --> 00:15:08,033
Но чтобы можно было наблюдать за процессом в работе, 

184
00:15:08,033 --> 00:15:10,833
установим таймер на текущую дату плюс пять секунд. 

185
00:15:10,833 --> 00:15:27,066
Таким образом, задача появится в списке задач администратора через пять секунд после создания приема;

186
00:15:27,066 --> 00:15:40,799
а также дата просрочки приема. Это дата приема плюс один день. 

187
00:15:40,800 --> 00:15:53,000
Для запуска процесса используем BprocRuntimeService. 

188
00:15:53,000 --> 00:15:59,666
Зададим process definition key, 

189
00:15:59,666 --> 00:16:11,432
instance name в качестве дополнительного  бизнес-ключа 

190
00:16:11,433 --> 00:16:13,399
и процессные переменные.

191
00:16:13,400 --> 00:16:14,266
На этом все. 

192
00:16:14,266 --> 00:16:17,799
При каждом создании приема будет запускаться бизнес-процесс.

193
00:16:19,533 --> 00:16:24,966
Следующим шагом будет создание спринг-бина, который реализует интерфейс UserProvider. 

194
00:16:24,966 --> 00:16:28,032
Мы используем этот бин во второй дорожке нашей модели, 

195
00:16:28,033 --> 00:16:31,466
чтобы задача автоматически назначалась на главного ветеринара. 

196
00:16:31,466 --> 00:16:35,166
Интерфейс содержит гет-метод, возвращающий пользователя, 

197
00:16:35,166 --> 00:16:38,066
который должен быть назначен как исполнитель задачи.

198
00:16:38,066 --> 00:16:45,232
Создадим новый бин под названием ChiefVetUserProvider. 

199
00:16:45,233 --> 00:16:49,599
Он реализует интерфейс UserProvider.

200
00:16:49,600 --> 00:16:55,800
Добавим постоянную, хранящую имя роли пользователя.

201
00:16:55,800 --> 00:17:01,900
Теперь нам нужно переопределить метод get. 

202
00:17:01,900 --> 00:17:09,266
В теле метода получаем список пользователей с ролью Chief. 

203
00:17:09,266 --> 00:17:28,666
Используем для загрузки данных DataManager, 

204
00:17:28,666 --> 00:17:32,666
в качестве параметра возьмем постоянную с именем роли.

205
00:17:32,666 --> 00:17:43,332
Если список пользователей пуст, будет возвращаться исключение с соответствующим сообщением. 

206
00:17:43,333 --> 00:17:48,133
Если нет, то первый пользователь из списка. 

207
00:17:48,133 --> 00:17:49,999
User Provider готов.

208
00:17:52,833 --> 00:17:56,766
В качестве формы для пользовательской задачи, которую получает ветеринар, 

209
00:17:56,766 --> 00:18:00,832
мы планировали использовать CUBA-скрин.

210
00:18:00,833 --> 00:18:04,899
Перейдем в дереве проекта на скринс и создадим новый пустой экран. 

211
00:18:11,400 --> 00:18:15,566
Нужно убедиться, что он не назначен на элементы вэб-меню. 

212
00:18:15,566 --> 00:18:18,966
Назовем его Visit. 

213
00:18:18,966 --> 00:18:22,532
Переключимся на дизайнер и смоделируем экран.

214
00:18:22,533 --> 00:18:24,366
Добавим компонент форм, 

215
00:18:24,366 --> 00:18:32,866
поместим pickerField и два компонента textArea на форму. 

216
00:18:32,866 --> 00:18:41,932
Зададим ID и подпись для pickerField  - Visit. 

217
00:18:41,933 --> 00:18:44,699
Метакласс - Visit. 

218
00:18:44,700 --> 00:18:46,833
Сделаем его нередактируемым.

219
00:18:46,833 --> 00:18:50,033
В первом текстовом поле будет отображаться комментарий владельца. 

220
00:18:59,400 --> 00:19:01,900
Сделаем его нередактируемым.

221
00:19:01,900 --> 00:19:04,733
Второе текстовое поле - для рекомендаций ветеринара. 

222
00:19:20,400 --> 00:19:23,300
Оставим его редактируемым.

223
00:19:23,300 --> 00:19:37,633
Теперь добавим hbox и разместим в нем две кнопки.

224
00:19:37,633 --> 00:19:40,499
Зададим подписи к кнопкам и ID. 

225
00:19:40,500 --> 00:19:47,533
Одна используется для завершения состоявшегося приема 

226
00:19:47,533 --> 00:19:50,699
и вторая для случая, когда клиент не пришел.

227
00:20:04,000 --> 00:20:05,633
Теперь перейдем в контроллер. 

228
00:20:05,633 --> 00:20:08,599
Сначала добавим две постоянных со статусами приема. 

229
00:20:22,800 --> 00:20:26,366
Теперь к экрану нужно добавить аннотацию @ProcessForm, 

230
00:20:26,366 --> 00:20:28,999
чтобы использовать экран как процессную форму. 

231
00:20:29,000 --> 00:20:33,033
Потом экран будет отображаться в списке процессных форм в дизайнере.

232
00:20:33,033 --> 00:20:37,666
Объявим два ауткама, которые будем использовать для потоков в дизайнере. 

233
00:20:37,666 --> 00:20:48,132
Используем атрибут outcomes аннотации @ProcessForm.

234
00:20:48,133 --> 00:20:51,099
Инжектируем textAreas и pickerField. 

235
00:21:04,866 --> 00:21:11,699
Добавим аннотацию @ProcessVariable, чтобы объявить, что инжектированный компонент - это процессная переменная. 

236
00:21:11,700 --> 00:21:15,966
Значения Visit и Owner’s comment уже определены в процессе, 

237
00:21:15,966 --> 00:21:19,566
так что в отображаемой форме они появятся в соответствующих полях. 

238
00:21:19,566 --> 00:21:22,999
Значение переменной recommendation еще не задано, 

239
00:21:23,000 --> 00:21:30,266
но аннотация @ProcessVariable будет учтена  во время завершения задачи.

240
00:21:30,266 --> 00:21:42,266
Инжектируем ProcessFormContext, который содержит информацию о пользовательской задаче и методы для завершения задачи.

241
00:21:42,266 --> 00:21:45,866
Теперь нам нужно обработать ClickEvents. 

242
00:21:45,866 --> 00:21:52,966
Подпишемся на событие visitCompletedBtn. 

243
00:21:52,966 --> 00:21:57,366
Создадим экземпляр TaskCompletion. 

244
00:21:57,366 --> 00:22:00,366
Установим соответствующий ауткам.

245
00:22:00,366 --> 00:22:04,766
Обозначим, что значения полей класса, аннотированных как @ProcessVariables, 

246
00:22:04,766 --> 00:22:08,366
должны собираться и храниться как процессные переменные. 

247
00:22:08,366 --> 00:22:09,599
Завершаем задачу.

248
00:22:17,166 --> 00:22:26,266
Подпишемся на событие PatientDidNotComeBtn. 

249
00:22:26,266 --> 00:22:32,466
Установим соответствующий ауткам. 

250
00:22:32,466 --> 00:22:39,266
Теперь мы пойдем другим путем   и вместо вызова метода saveInjectedProcessVariables() определим переменные напрямую.

251
00:22:45,500 --> 00:22:48,466
На этом настройка экрана CUBA завершена.

252
00:22:50,100 --> 00:22:54,166
Наконец, добавим сервисные задачи. 

253
00:22:54,166 --> 00:22:59,866
Нам нужно, чтобы процесс автоматически завершался, когда прием состоялся или администратор его отменил. 

254
00:22:59,866 --> 00:23:02,899
Единственное, что нам нужно сделать до завершения задачи - 

255
00:23:02,900 --> 00:23:06,000
установить соответствующий статус приема. 

256
00:23:06,000 --> 00:23:13,833
Создадим простой бин с методом сэт-стАтус, 

257
00:23:13,833 --> 00:23:19,799
который в качестве параметров получает прием и строку с его статусом.

258
00:23:19,800 --> 00:23:29,266
Инжектируем DataManager. 

259
00:23:29,266 --> 00:23:40,866
В теле метода перезагрузим Visit, 

260
00:23:40,866 --> 00:23:46,899
установим статус и сохраним изменения. 

261
00:23:46,900 --> 00:23:48,300
На этом все. 

262
00:23:48,300 --> 00:23:52,566
Вторая сервисная задача завершает процесс после окончания приема. 

263
00:23:52,566 --> 00:23:56,899
Для этой цели мы используем JavaDelegate. 

264
00:23:56,900 --> 00:23:59,000
В core-модуле создадим новый класс. 

265
00:24:10,900 --> 00:24:13,700
Он должен реализовать интерфейс JavaDelegate, 

266
00:24:13,700 --> 00:24:16,366
который требует реализации метода execute. 

267
00:24:16,366 --> 00:24:21,466
Он вызывается каждый раз, когда процесс достигает сервисной задачи.

268
00:24:21,466 --> 00:24:28,499
Объявим поле Expression, определенное в модели процесса. 

269
00:24:28,500 --> 00:24:31,166
И добавим постоянную со статусом Completed.

270
00:24:40,566 --> 00:24:58,466
Получим процессные переменные: Visit и recommendations.

271
00:24:58,466 --> 00:25:00,899
И нам нужно перезагрузить переменную Visit, 

272
00:25:00,900 --> 00:25:06,600
в ней должна содержаться  информация о владельце и его имейле. 

273
00:25:06,600 --> 00:25:08,733
Создадим новое представление.

274
00:25:24,433 --> 00:25:36,233
Установим статус и рекомендации для приема и сохраним эти данные.

275
00:25:36,233 --> 00:25:46,566
Чтобы отправить письмо владельцу, возьмем адрес его электронной почты. 

276
00:25:46,566 --> 00:25:55,932
И получим строковое представление шаблона письма. 

277
00:25:55,933 --> 00:25:58,499
Затем вызовем метод sendEmail . 

278
00:25:58,500 --> 00:26:00,433
У нас нет задачи отправить реальное письмо, 

279
00:26:00,433 --> 00:26:05,033
поэтому в теле метода sendEmail() запишем сообщение в файл с логами.

280
00:26:36,333 --> 00:26:38,633
Мы сделали в коде все, что планировали. 

281
00:26:40,333 --> 00:26:46,099
Теперь закончим моделирование бизнес-процесса и проверим его в работе. 

282
00:26:46,100 --> 00:27:01,966
Запустим приложение, войдем как администратор и перейдем на экран дизайнера.

283
00:27:01,966 --> 00:27:08,732
Откроем модель бизнес-процесса из черновика. 

284
00:27:08,733 --> 00:27:12,933
Настроим спринг-бин для сервисной задачи Set status “Canceled” 

285
00:27:12,933 --> 00:27:21,266
и передадим ему в качестве параметров процессную переменную Visit и статус canceled. 

286
00:27:21,266 --> 00:27:24,999
То же самое сделаем для задачи Set status “Patient did not come”, 

287
00:27:25,000 --> 00:27:31,066
но передадим другой соответствующий статус.

288
00:27:31,066 --> 00:27:36,732
Теперь можно настроить User Provider для второй дорожки.

289
00:27:36,733 --> 00:27:42,166
Для пользовательской задачи Visit выберем созданный CUBA-экран. 

290
00:27:42,166 --> 00:27:45,932
Мы видим, что ауткамы появились в свойствах задачи. 

291
00:27:45,933 --> 00:27:49,833
Теперь установим ауткамы для соответствующих элементов “поток”.

292
00:27:59,466 --> 00:28:08,199
И установим класс Java Delegate.

293
00:28:08,200 --> 00:28:13,533
Теперь наша модель готова к развертыванию. 

294
00:28:13,533 --> 00:28:17,599
После этого описание процесса будет доступно на экране Process Definition. 

295
00:28:17,600 --> 00:28:24,133
Его можно открыть в дизайнере и обновить или просмотреть детали в экране редактора.

296
00:28:24,133 --> 00:28:31,233
Протестируем созданный процесс. 

297
00:28:26,233 --> 00:28:40,966
Перейдем в браузер приемов и создадим три новых приема. 

298
00:28:40,966 --> 00:28:44,566
Теперь мы видим приемы без статуса, созданные вместе с базой,  

299
00:28:44,566 --> 00:28:46,966
и три новых приема со статусом New.

300
00:28:46,966 --> 00:28:49,299
Перейдем на экран My Tasks. 

301
00:28:49,300 --> 00:28:52,666
Первый таймер установлен на текущую дату плюс пять секунд, 

302
00:28:52,666 --> 00:28:58,832
так что администратор уже увидел эти приемы и может их подтвердить или отменить.

303
00:28:58,833 --> 00:29:03,066
Отменим первый прием. 

304
00:29:03,066 --> 00:29:05,366
Перейдем в браузер приемов. 

305
00:29:05,366 --> 00:29:08,632
У отмененного приема появился соответствующий статус.

306
00:29:08,633 --> 00:29:12,299
Теперь подтвердим остальные приемы. 

307
00:29:12,300 --> 00:29:20,100
Добавим информацию в поле для комментария владельца. 

308
00:29:20,100 --> 00:29:22,533
Главный ветеринар получил задачи. 

309
00:29:22,533 --> 00:29:24,633
Перейдем в аккаунт с ролью Chief, 

310
00:29:24,633 --> 00:29:30,999
пароль и логин одинаковые. 

311
00:29:31,000 --> 00:29:39,633
Главный ветеринар должен назначить приемы ветеринарам. 
 

312
00:29:39,633 --> 00:29:45,233
Перейдем в аккаунт ветеринара, пароль и логин одинаковые. 

313
00:29:45,233 --> 00:29:49,199
У ветеринара появилось два приема. 

314
00:29:49,200 --> 00:29:52,500
Откроем первый. Вот созданный нами ранее CUBA-экран. 

315
00:29:52,500 --> 00:29:55,700
Теперь поле с комментарием пользователя стало нередактируемым. 

316
00:29:55,700 --> 00:30:00,966
Напишем несколько рекомендаций и нажмем Visit completed. 

317
00:30:00,966 --> 00:30:05,199
В этот момент вызывается метод execute класса Java Delegate. 

318
00:30:05,200 --> 00:30:10,133
Посмотрим логи и убедимся, что он работает корректно.

319
00:30:10,133 --> 00:30:13,599
И наконец проверим ситуацию, в которой клиент не пришел. 

320
00:30:13,600 --> 00:30:19,433
Откроем последний прием и нажмем кнопку Patient did not come. 

321
00:30:19,433 --> 00:30:22,533
Перейдем в браузер приемов и проверим статусы приемов. 

322
00:30:22,533 --> 00:30:24,833
Все записи соответствуют результату

323
00:30:24,833 --> 00:30:27,799
Убедимся, что все экземпляры процесса завершены, 

324
00:30:27,800 --> 00:30:32,033
перейдем на экран экземпляров процесса и найдем активные. 

325
00:30:32,033 --> 00:30:38,266
Список пуст - значит, наш бизнес-процесс и его код работают как надо!

326
00:30:38,266 --> 00:30:41,066
Итак, мы сделали все, что планировали. 

327
00:30:41,066 --> 00:30:44,666
Присоединяйтесь к сообществу и смело задавайте любые вопросы. 

328
00:30:44,666 --> 00:30:48,432
Скачивайте и используйте другие дополнения из каталога CUBA. 

329
00:30:48,433 --> 00:30:52,866
Ответы на многие вопросы можно найти в документации на нашем сайте. 

330
00:30:52,866 --> 00:30:56,366
Подписывайтесь на нас на GitHub, на наш Twitter и Youtube-канал! 

331
00:30:56,366 --> 00:30:59,799
Все ссылки доступны под видео. Спасибо за просмотр!